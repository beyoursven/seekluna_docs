# 矩阵 DP

顾名思义，在矩阵、网格图上做的 DP。

对于矩阵类的 DP，你可以通过网格图搜索的方式找到状态和转移。

## atcoder dp_h

状态：$dp(i, j)$ 表示从 $(1, 1)$ 走到 $(i, j)$ 的方案数。
转移：对于不为障碍的格子 $(i, j)$，$dp_{i, j} = dp_{i - 1, j} + dp_{i, j - 1}$。
拓扑序：$i$ 从小到大（或者 $j$ 从小到大）。

时空复杂度均为 $O(NM)$。

??? 代码

    ```cpp
    #include <bits/stdc++.h>

    using namespace std;

    const int MAXN = 1e3 + 1, MOD = 1e9 + 7;

    int n, m, dp[MAXN][MAXN];
    char c[MAXN][MAXN];

    int main() {
      cin >> n >> m;
      for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
          cin >> c[i][j];
        }
      }
      dp[1][1] = 1;
      for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
          if ((i + j > 2 && c[i][j] != '#')) {
            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD;
          }
        }
      }
      cout << dp[n][m];
      return 0;
    }
    ```

注意使用收集型实现矩阵类 DP 时，需要保证被收集的状态已被求解过。

## 洛谷 P1006

??? 形式化题意

    给定一个 $n \times m$ 的数字矩阵，你需要找到一条从左上到右下的路径（只能向右向下走）和一条从右下到左上的路径（只能向上向左走），并且两条路径不能相交。请你求出经过的数字的最大值。

??? 提示

    把两条路径都看做是左上到右下角的路径。然后尝试实现搜索，如何实现转移，并且保证路径不相交？

??? 状态和转移

    $dp{x1, y1, x2, y2}$ 表示两条路径从左上角分别**同时**走到 $(x1, y1)$ 和 $(x2, y2)$ 时的最大数字和。**同时**意味着 $x1 + y1 = x2 + y2$。注意路径不能相交，因此不能存在 $x1 = x2, y1 = y2$ 的情况。

    转移就枚举 $(x1, y1)$ 和 $(x2, y2)$ 行走的情况，一共四种。

    时空复杂度均为 $O(n^2m^2)$。

??? 优化

    已知 $x1, y1, x2$，可以推出 $y2$，因此可以降低一个维度。时空复杂度均为 $O(n^2m)$ 或者 $O(nm^2)$。

当你无法处理好转移的细节时，不妨用 `搜索 -> 记忆化搜索` 的方式完成此题。
# 序列 DP

## 最长上升子序列

longest increasing subsequence，简称 LIS。

### 洛谷 B3637

状态：$dp_i$ 表示以 $i$​ 结尾的 LIS 的最长长度。

直接做 $O(N^2)$ dp。

### CSES 1145

LIS 的 $O(n \log n)$ 实现，本处讲解二分，以后讲解数据结构优化。

一开始用搜索实现 LIS 的状态设计为 $(i, x)$，表示上升子序列末尾元素为 $a_i$，长度为 $x$。

类似于 CF1582F1，假设考虑完前 $i$ 个元素后，有很多长度为 $x$ 的上升子序列，那对于长度为 $x$ 的上升子序列肯定是末尾元素越小越好。

因此重新设计状态 $dp_{i, x}$ 表示考虑前 $i$ 个元素的长度为 $x$ 的上升子序列的末尾元素最小值。初始化方面，由于一开始只有空序列，所以 $dp_{0, 1} \sim dp_{0, n}$ 都为 $\infty$。

可以发现每个 $dp_{i, 1} \sim dp_{i, n}$ 是严格单调递增的，可以用反证法证明：

- 假设存在一个 $x(0 \le x \le n - 1)$ 使得 $dp_{i, x} \ge dp_{i, x + 1}$ 并且 $dp_{i, x + 1} \ne \infty$。
- 令前 $i$ 个元素中长度为 $x + 1$ 的某个上升子序列的值依次为 $p_1 \lt p_2 \lt \dots \lt p_{x + 1} = dp_{i, x + 1}$。
- 那么对于长度为 $x$ 的上升子序列 $p_1 \lt p_2 \dots \lt p_x \lt dp_{i, x + 1} \le dp_{i, x}$。末尾元素 $p_x$ 比 $dp_{i, x}$ 小，与 $dp_{i, x}$ 的定义矛盾。反证法成立。

观察转移：

- 可以不选第 $i + 1$ 个元素，因此先 $dp_{i + 1, x} = dp_{i, x}$
- 如果选 $a_{i + 1}$，则可以找到 $dp_{i + 1, x} \ge a_{i + 1}$ 中的最小的 $x$（为了保证 $dp_{i + 1}$ 的单调性），然后更新 $dp_{i + 1, x}$ 的值。
- 每次只会修改 $dp_{i + 1}$ 中的一个值，因此可以直接降维优化。

空间复杂度 $O(N)$，时间复杂度 $O(N \log N)$。

## 划分 DP

划分 DP：在数组中选 $k$ 个元素、选 $k$ 个互不相交的子段、分为 $k$ 个子段的一类动态规划模型。相当于是在子序列问题的基础之上加了一个选数数量的限制。

划分 DP 经常与各种各样的优化结合起来考察（因为状态比较好想），例如前缀和、双指针、累加和、单调队列、线段树等一系列数据结构优化。

### 洛谷 P9688

令 $dp_{x, i}$ 表示在前 $i$ 种颜色中选了 $x$ 种颜色，最后选的颜色为 $i$ 的最大价值。

转移时考虑枚举上一个选了颜色 $j$，则 $dp_{x, i}$ 可以由 $dp_{x - 1, j}$ 转移而来，需要满足的条件时 $j \lt i$、颜色 $i, j$ 都出现、颜色为 $i$ 的格子全部在颜色为 $j$ 的格子的右边。这些限制条件可以通过预处理每种颜色的最早、最晚格子来实现。

$dp$ 过程的空间复杂度 $O(NK)$，时间复杂度 $O(N^2K)$​。

**划分 $dp$ 的拓扑序，可以是 $x$ 从小到大，也可以是 $i$ 从小到大。**

### CF1133E

??? 形式化题意

    给定 $n$ 个整数 $a_i$，你需要将整数分为最多 $k$ 组，每个整数最多分到一组，并且每组内整数的极差不超过 $5$。求最多有多少整数被分组。$1 \le k \le n \le 5000$。

??? 提示

    不难想到，可以先排序，此时每组内的整数一定是排序后的一段连续的区间。

??? 状态和转移

    定义状态 $dp_{i, j}$ 表示前 $i$ 个整数分为了 $j$ 个非空组时选出的最多数量。

    考虑收集型转移。如果 $a_i$ 不被分组，显然有转移 $dp_{i, j} = \max(dp_{i - 1, j})$。否则，可以考虑枚举第 $j$ 组选的第一个整数 $a_k$，需要满足 $a_i - a_k \le 5$，然后做转移 $dp_{i, j} = \max{dp_{i, j}, dp_{k - 1, j - 1} + i - k + 1}$。
    
    空间复杂度 $O(nk)$，时间复杂度 $O(n^2k)$，TLE。

??? 优化

    如果 $a_i$ 被分组，我们需要将尽可能多的整数和 $a_i$ 一组。形式化地说，就是找到最小的满足 $a_i - a_k \le 5$ 的 $k$，然后只做一次这个 $k$ 的转移。
    
    可以通过二分或者双指针预处理处每个 $i$ 对应的 $k$。

    预处理时间复杂度 $O(n) \sim O(n \log n)$，dp 的时间复杂度优化为 $O(nk)$。

??? 证明

    思维证明：当分出的组数 $j$ 一定时，元素数量越少，越有可能全部被分组。一方面转移保证了第 $j$ 组选出的数字尽可能多，另一方面保证前 $k - 1$ 个数字尽可能都被分组。

    形式化证明：$0 \le dp_{i, j} - dp_{i - 1, j} \le 1$，则对于 $k$ 和 $k + 1$ 的转移有 $(dp_{k - 1, j - 1} + i - k + 1) - (dp_{k, j - 1} + i - k) \ge 0$，也就是说决策 $k$ 比 $k + 1$ 更优。
    

### CF467C

## 时间序列上 DP

### CSES 1140

时间序列上的 $dp$。我们先考虑 $a_i, b_i \le 10^5$ 时间范围比较小的情况。

令 $dp_i$ 表示到时刻 $i$ **结束**时的最大获利。

分以下两种情况进行转移：

- 首先 $dp_i = dp_{i - 1}$，表示时刻 $i$ 之前没有进行项目进行。

- 如果时刻 $i$ 是某些项目 $j$ 的结束时刻，则 $dp_i = \max\{ dp_{a_j - 1} + p_j\}$，表示在时刻 $i$ 时进行了项目。

拓扑序显然为 $i$ 从小到大，快速查找 $j$ 是要做的事情，有两种实现方法

- 对所有任务按结束时刻排序，然后双指针的方式维护 $j$。
- 将以时刻 $i$ 结束的任务用 `vector` 记录，然后转移时直接遍历对应的 `vector`。

$dp$ 过程的时间复杂度 $O(N + T)$，其中 $N$ 为任务数量，$T$​ 为时间长度。 

由于题目的 $a_i, b_i \le 10^9$，因此我们将所有出现的时刻离散化处理即可。

#### 离散化

```cpp
int cnt = 0;
int t[];  // vector<int> t;
for (int i = 1; i <= n; i++) {
  cin >> a[i];
  t[++cnt] = a[i];
  // t.push_back(a[i]);
}
sort(t + 1, t + cnt + 1);
// unique 返回已排序范围中去重后的数列的最后一个元素的后一个地址或迭代器
// int m = unique(t + 1, t + cnt + 1) - t - 1;
// sort(t.begin(), t.end());
// t.erase(unique(t.begin(), t.end()), t.end());
/*
	for (int i = 1; i <= cnt; i++) {
		if (i == 1 || a[i] != a[i - 1]) {
			a[++m] = a[i];
		}
	}
*/
for (int i = 1; i <= n; i++) {
  a[i] = lower_bound(t + 1, t + cnt + 1, a[i]) - t;  
  // 或 lower_bound(t.begin(), t.end(), a[i]) - t.begin() + 1;
}
```

```cpp
map<int, int> h;
for (int i = 1; i <= n; i++) {
  cin >> a[i];
  h[a[i]] = 1;
}
int cnt = 0;
for (pair<int, int> &it : h) {
  it.second = ++cnt;
}

// h[x] 记录了 x 离散化后的值
```

NOI 系列赛事建议使用第一种（数组模拟，不是 `vector`），常数小。

### 洛谷 P1280

与 CSES 1140 类似，不过有一个转移处理起来有些细节：在某时刻有任务时，必须做其中一个任务。

考虑如下情况：

- 如果当前时刻 $i$ 没有任务开始，收集型转移 $dp_i \gets dp_{i - 1} + 1$
- 否则当前时刻开始的任务是 $j$，扩散型转移 $dp_{i - 1} \to dp_{p_j + t_j - 1}$

## 其他题目

### abc271_e

从 $1$ 到 $N$ 的路径的编号序列是 $E$ 的一个子序列。

看似状态为 $dp_i$ 以边 $E_i$ 结尾的，从 $1$ 到 $B_{E_i}$​ 的最少长度。

下一条边的选取必须要以当前边的终点为起点。

重新设计状态为 $dp_{i, u}$ 表示考虑了边 $E_1, \dots, E_i$，从 $1$ 到 $u$ 的最少路径长度。

转移为
$$
dp_{i, u} = 
\begin{cases} 
\begin{aligned}
dp_{i - 1, u}&, &E_i \ne (u, v)\\
\min(dp_{i - 1, u}, dp_{i - 1, v})&, &E_i = (u, v)
\end{aligned}
\end{cases}
$$

首先可以发现可以省略第一维，其次发现转移时只需要做 $E_i = (u, v)$​ 的转移，因此第一维是毫无用处的。

这里用到的思维总结成一句话：做序列型 $dp$ 不一定要用元素下标当 $dp$ 状态，也可以用元素值当 $dp$ 的状态。

### CF1582F1

很自然的可以得到这样一个状态设计：$(i, x)$ 表示上升子序列末尾元素为 $a_i$，子序列异或值为 $x$。

直接暴力做递推，时间 $O(N^2 \times V)$，其中 $V = 512$，不能接受。

可以观察到，假设考虑完前 $i$ 个元素，有很多上升子序列的值为 $x$，那我肯定是贪心地选择这些子序列中末尾元素尽可能小的，因为这样子能够让后续的元素尽可能做转移。

优化下状态设计，$dp_{i, x}$ 表示考虑前 $i$ 个元素的上升子序列的异或值为 $x$ 的末尾元素最小值。转移就是选或不选当前元素。可以发现转移发生在 $dp_i$ 和 $dp_{i - 1}$ 之间，因此可以滚动数组优化空间。

空间复杂度 $O(V)$，时间复杂度 $O(N \times V)$。






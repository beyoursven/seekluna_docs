# 最长上升子序列

通过最长上升子序列（Longest Increasing Subsequence）问题，找出搜索、状态图遍历、递推、动态规划、分治和记忆化之间的联系。

## 问题 1：求最长上升子序列的长度

!!! 题意

    给定长度为 $n$ 的整数序列 $a_1, a_2, \dots, a_n$，请你求出 $a$ 的上升子序列的最长长度。上升子序列 $b$ 定义如下：

    - 令 $b$ 的长度为 $m$（$0 \le m \le n$），$b$ 中的元素为 $b_1, b_2, \dots, b_m$。
    - $1 \le b_1 \lt b_2 \lt \dots \lt b_m \le n$，且 $a_{b_1} \lt a_{b_2} \lt \dots \lt a_{b_m}$。

### 方法 1：搜索

通过搜索找出所有子序列，并对每个子序列逐个进行判定。

```cpp
const int MAXN = 1e3 + 1;

int n, a[MAXN];
int b[MAXN], ans;

bool is_LIS(int b[], int m) {
  for (int i = 2; i <= m; i++) {
    if (a[b[i]] <= a[b[i - 1]]) {
      return 0;
    }
  }
  return 1;
}

void dfs(int len) {
  if (is_LIS(b, len)) {
    ans = max(ans, len);  // 更新答案
  }
  for (int i = 1; i <= n; i++) {  // 枚举转移
    if (i > b[len]) {
      b[len + 1] = i;
      dfs(len + 1);
    }
  }
}

dfs(0);
cout << ans;
```

（可以采取的提问：为什么没有显著的递归退出）

（本方法还可以被状压枚举替代）

可以观察到状态是子序列本身，转移是在子序列末尾添加一个下标更大的元素。

空间复杂度：递归深度 $O(n)$。

时间复杂度：一共有 $O(2^n)$ 个子序列，每个子序列的判定 $O(n)$，总时间 $O(n \times 2^n)$。

### 方法 2：搜索

我们可以对方法 1 的状态进行优化。

可以观察到，上升子序列的构造过程（转移）仅与子序列末尾元素的下标相关。对于所有末尾元素下标相同的子序列，它们能够做的转移都是相同的。并且本题是求解最长上升子序列的长度，并不关心子序列具体长什么样子。

若只关心末尾元素下标，则丢失了子序列的长度信息。我们需要将所有的上升子序列按照末尾元素下标和长度进行分组。

因此将状态重新设计为 $(i, len)$，表示子序列末尾元素下标为 $i$、长度为 $len$ 的子序列。

转移则是往末尾添加一个下标更大且元素值更大的元素，即 $(i, len) \to (j, len + 1)$，其中 $i \lt j \le n$ 且 $a_i \le a_j$。

```cpp
const int MAXN = 1e3 + 1;

int n, a[MAXN];
int ans;

void dfs(int i, int len) {
  ans = max(ans, len);                // 更新答案
  for (int j = i + 1; i <= n; i++) {  // 枚举转移
    if (a[i] < a[j]) {
      dfs(j, len + 1);
    }
  }
}

a[0] = INT_MIN;                 // 可以把空序列看做为一个拥有极小值的序列
dfs(0, 0);                      // 初始状态为空序列
cout << ans;

for (int i = 1; i <= n; i++) {  // 也可以将单个元素构成的序列作为初始状态
  dfs(i, 1);
}
```

时间复杂度：上述搜索可以构造出所有的上升子序列，最坏情况有 $O(2^n)$ 个上升子序列，因此总时间 $O(2^n)$。

### 方法 3：状态图遍历

重新将状态和转移形式化的描述一下。

状态：$(i, len)$，表示子序列末尾元素下标为 $i$、长度为 $len$ 的子序列。

转移：$(i, len) \to (j, len + 1)$，其中 $i \lt j \le n$ 且 $a_i \le a_j$，表示往末尾添加一个下标更大且元素值更大的元素。

既然这样的状态设计已经包含了解决该问题的信息，可以直接做状态图遍历，保证每个状态只被遍历（计算）一次。

```cpp
const int MAXN = 1e3 + 1;

int n, a[MAXN], vis[MAXN][MAXN];
int ans;

void dfs(int i, int len) {
  if (vis[i][len]) {
    return ;
  }
  vis[i][len] = 1;                    // 标记状态
  ans = max(ans, len);                // 更新答案
  for (int j = i + 1; i <= n; i++) {  // 枚举转移
    if (a[i] < a[j]) {
      dfs(j, len + 1);
    }
  }
}

a[0] = INT_MIN;                 // 可以把空序列看做为一个拥有极小值的序列
dfs(0, 0);                      // 初始状态为空序列
cout << ans;

for (int i = 1; i <= n; i++) {  // 也可以将单个元素构成的序列作为初始状态
  dfs(i, 1);
}
```

时间复杂度：一共有 $O(n^2)$ 个状态，每个状态转移数量 $O(n)$，总时间 $O(n^3)$。

### 方法 4：递推

重新将状态和转移形式化的描述一下。

状态：$(i, len)$，表示子序列末尾元素下标为 $i$、长度为 $len$ 的子序列。

转移：$(i, len) \to (j, len + 1)$，其中 $i \lt j \le n$ 且 $a_i \le a_j$，表示往末尾添加一个下标更大且元素值更大的元素。

可以观察到在该状态转移的过程中，拓扑序可以是 $i$ 从小到大，或者 $len$ 从小到大，因此我们可以用递推的方式进行求解。如下代码给出收集型递推实现，并且将初始状态看为单个元素构成的序列。

!!! 代码

    === "拓扑序：$i$ 从 $1$ 到 $n$

        ```cpp
        const int MAXN = 1e3 + 1;

        int n, a[MAXN];
        int ans, f[MAXN][MAXN];

        for (int i = 1; i <= n; i++) {          // 枚举拓扑序（枚举阶段）
          f[i][1] = 1;                          // 初始状态初始化
          for (int len = 2; len <= n; len++) {  // 枚举状态
            for (int j = 1; j < i; j++) {       // 枚举转移
              if (a[j] < a[i]) {                // 限制条件
                f[i][len] |= f[j][len - 1];     // 收集型转移
              }
            }
            if (f[i][len]) {        // 状态存在
              ans = max(ans, len);  // 更新答案
            }
          }
        }
        cout << ans;
        ```

    === "拓扑序：$len$ 从 $1$ 到 $n$

        ```cpp
        const int MAXN = 1e3 + 1;

        int n, a[MAXN];
        int ans, f[MAXN][MAXN];

        for (int i = 1; i <= n; i++) {  // 初始状态初始化
          f[len][i] = 1;
        }
        for (int len = 2; len <= n; len++) {  // 枚举拓扑序（枚举阶段）
          for (int i = len; i <= n; i++) {    // 枚举状态
            for (int j = 1; j < i; j++) {     // 枚举转移
              if (a[j] < a[i]) {              // 限制条件
                f[len][i] |= f[len - 1][j];   // 收集型转移
              }
            }
            if (f[len][i]) {        // 状态存在
              ans = max(ans, len);  // 更新答案
            }
          }
        }
        cout << ans;
        ```

在时间复杂度上，与方法 $3$ 一样，都是 $O(n^3)$。

### 方法 5：动态规划

重新将状态和转移形式化的描述一下。

状态：$(i, len)$，表示子序列末尾元素下标为 $i$、长度为 $len$ 的子序列。

转移：$(i, len) \to (j, len + 1)$，其中 $i \lt j \le n$ 且 $a_i \le a_j$，表示往末尾添加一个下标更大且元素值更大的元素。

首先观察到最优化属性显然是 $len$，对所有状态按末尾元素下标 $i$ 进行分组。可以观察到如下许多性质：

- $len$ 是最优化属性，对于同一分组 $(i)$ 来说，只需要保留最大的 $len$，作为最优状态。
- 上升子序列的构造只与末尾元素相关，与长度无关。
- 无后效性：分组存在拓扑序，即 $i$ 从 $1$ 到 $n$。
- 最优子结构：每个分组中的最优状态一定由拓扑序中靠前的分组的最优状态转移而来。
  - 换句话说，末尾下标为 $i$ 的 LIS 的最长长度显然可以由末尾下标更小的 LIS 的最长长度转移而来。
  - 通俗来说，当前最优由之前最优转移而来。

使用动态规划进行求解。

```cpp
const int MAXN = 1e3 + 1;

int n, a[MAXN];
int ans;
int dp[MAXN];  // 对于每个分组 i，只记录最大的 len

for (int i = 1; i <= n; i++)  {       // 枚举分组拓扑序（枚举阶段）
  dp[i] = 1;                          // 初始状态初始化
  for (int j = 1; j < i; j++) {       // 枚举转移
    if (a[j] < a[i]) {                // 限制条件
      dp[i] = max(dp[i], dp[j] + 1);  // 收集型转移
    }
  }
  ans = max(ans, dp[i]);  // 更新答案
}
cout << ans;
```

空间复杂度：$n$ 个状态（分组，在 DP 问题中简述为状态），$O(n)$。

时间复杂度：每个状态转移数 $O(n)$，总时间复杂度 $O(n^2)$。

### 状态转移方程

将上述流程进行整理，可以得到老式教学中的状态转移方程。

状态：令 $dp_i$ 表示以下标 $i$ 结尾的上升子序列的最长长度。

转移方程：$dp_i = \max \limits_{j \lt i, A_j \lt A_i} \{ dp_j \} + 1$。

分组拓扑序（阶段）：$i$ 从 $1$ 到 $n$。

目标：求解 $\max \limits_{i = 1}^n \{ dp_i \}$。

!!! 代码

    === "收集型"

        ```cpp
        for (int i = 1; i <= n; i++) {        // 阶段的拓扑序
          dp[i] = 1;                          // 初始化一个元素的序列
          for (int j = 1; j < i; j++) {       // 转移
            if (a[j] < a[i]) {                // 限制条件
              dp[i] = max(dp[i], dp[j] + 1);  // 收集型转移
            }
          }
          ans = max(ans, dp[i]);  // 维护答案
        }
        cout << ans;
        ```

    === "扩散型“

        ```cpp
        for (int i = 1; i <= n; i++) {
          dp[i] = 1;
        }
        for (int i = 1; i <= n; i++) {
          ans = max(ans, dp[i]);
          for (int j = i + 1; j <= n; j++) {
            if (a[i] < a[j]) {
              dp[j] = max(dp[j], dp[i] + 1);
            }
          }
        }
        cout << ans;
        ```

    === "记忆化搜索"

        ```cpp
        // 待编写
        ```

### 方法 6

[$O(n \log n)$ 求解 LIS](sequence_dp.md)

### 总结

在方法 1 和方法 2 中，我们尝试用搜索解决这个最优化问题。

在方法 3 中，我们重新设计状态，缩小状态空间，将最优化问题转为了可行性（判定性）问题，使用状态图遍历进行求解。

在方法 4 中，找到状态转移的拓扑序，使用递推求解可行性问题。

在方法 5 中，进一步分析状态的最优化属性、分组拓扑序、最优子结构，再次将可行性问题转为了最优化问题，使用动态规划进行求解。并且还可以从分治角度理解动态规划。

在方法 6 中，挖掘更多的子结构性质，尝试进行优化（这样的优化没有套路，是 ad-hoc 的）。

早期的 DP 训练和总结中，需要明确以下几点（这也是总结的格式）：

- 状态
- 转移
- 拓扑序
- 最优化属性
- 分组拓扑序
- 最优子结构
- 初始状态，目标状态

当常规的 DP 题熟练之后，可以直接写“状态转移方程”。

## 问题 2：求最长上升子序列的一个方案

!!! 题意

    给定长度为 $n$ 的整数序列 $a_1, a_2, \dots, a_n$，请你求出 $a$ 的一个 LIS。

我们用 DP 求解 LIS 的长度，该如何求解方案呢？需要回到状态理论的理解。[理论](/docs/dp/theory/theory.md)

### 方法 1：状态关联

```cpp
// 输出以 A[i] 结尾的最长上升子序列（任意一种即可）
void Print(int i) {
  if (!i) {  // 边界，空序列
    return;
  }
  for (int j = 0; j < i; j++) {                // 枚举状态
    if (a[j] <= a[i] && dp[j] + 1 == dp[i]) {  // 状态关联，判断两个状态间是否存在最优转移
      Print(j);
      break;
    }
  }
  cout << a[i] << ' ';
}

a[0] = 0;                             // 初始化
for (int i = 1; i <= n; i++) {        // 阶段的拓扑序
  for (int j = 0; j < i; j++) {       // 枚举状态转移（状态关联）
    if (a[j] <= a[i]) {               // 限制条件
      dp[i] = max(dp[i], dp[j] + 1);  // 收集型转移
    }
  }
  if (dp[i] > ans) {  // 维护答案
    ans = dp[i];
    pos = i;
  }
}

Print(pos);  // 从目标状态反向转移，还原方案
```

输出方案的时间复杂度 $O(N)$。也可以用非递归：

```cpp
for (int i = pos, j; i; i = j) {               // 从目标状态反向转移，还原方案
  res[++m] = a[i];                             // 记录方案
  for (j = i; j >= 1; j--) {                   // 枚举状态
    if (a[j] <= a[i] && dp[j] + 1 == dp[i]) {  // 状态关联，判断两个状态间是否存在最优转移
      break;
    }
  }
}
for (int i = m; i >= 1; i--) {
  cout << res[i] << ' ';
}
```

### 方法 2：记录最优转移

```cpp
void Print(int i) {
  if (!i) {
    return;
  }
  Print(pre[i]);
  cout << a[i] << ' ';
}

a[0] = 0;                                     // 初始化
for (int i = 1; i <= n; i++) {                // 阶段的拓扑序
  for (int j = 0; j < i; j++) {               // 枚举状态转移（状态关联）
    if (a[j] <= a[i] && dp[j] + 1 > dp[i]) {  // 限制条件
      dp[i] = dp[j] + 1;                      // 收集型转移
      pre[i] = j;                             // 记录最优转移
    }
  }
  if (dp[i] > ans) {       // 维护答案
    ans = dp[i], pos = i;  // 记录最优状态
  }
}
cout << "max=" << ans << '\n';
Print(pos);
```

输出方案的时间复杂度 $O(N)$，开辟了额外的记录最优转移的数组 $O(N)$。

## 问题 3：求最长上升子序列的方案数

!!! 题意

    给定长度为 $n$ 的整数序列 $a_1, a_2, \dots, a_n$，请你求出 $a$ 的 LIS 的方案数。

最优化问题也可以附带方案数问题。对于 DP 来说，最优状态也是将原始状态合并后的状态，因此可以拥有方案数。实际上状态进行了两次合并：

- 首先合并等价状态得到方案数。
- 然后每个分组只保留最优的状态及其对应方案数。

可以在 DP 的过程中同时求解方案数。根据是否为最优转移来决定方案数的合并：

- 如果存在更优的状态，之前方案作废，将更优转移的方案全部覆盖。
- 如果转移同时最优，方案数累加。

```cpp
cnt[0] = 1;                                // 初始化空序列
for (int i = 1; i <= n; i++) {             // 阶段的拓扑序
  for (int j = 0; j < i; j++) {            // 转移
    if (a[j] < a[i]) {                     // 限制条件
      if (dp[j] + 1 > dp[i]) {             // 存在更长的 LIS
        dp[i] = dp[j] + 1;                 // 收集型转移
        cnt[i] = cnt[j];                   // 所有以 i 结尾的 LIS 由所有以 j 结尾的 LIS 转移而来
      } else if (dp[j] + 1 == dp[i]) {     // 同样长度的 LIS
        cnt[i] = (cnt[i] + cnt[j]) % MOD;  // 累加方案数
      }
    }
  }
  if (dp[i] > ans) {  // 维护答案
    ans = dp[i], res = cnt[i];
  } else if (dp[i] == ans) {
    res = (res + cnt[i]) % MOD;
  }
}
cout << ans << ' ' << res;
```

## 问题 4：求最长上升子序列的所有方案

!!! 题意

    给定长度为 $n$ 的整数序列 $a_1, a_2, \dots, a_n$，请你求出 $a$ 的所有 LIS。保证输出不超时。

问题 3 中的方案数是合并后的结果，所以可以在 DP 的过程中同时求解。本题要求解 LIS 的所有方案。

首先只求解问题 1，得到一个状态转移图，图上的每个转移都对应了 DP 过程中的最优转移。

然后基于该状态转移图，搜索出所有的方案。

```cpp
```

## 问题 5：求字典序最小的最长上升子序列的方案

!!! 题意

    给定长度为 $n$ 的整数序列 $a_1, a_2, \dots, a_n$，请你求出 $a$ 的下标字典序最小的 LIS。

参考问题 $4$，得到 DP 过程的状态转移图后，找该图上的一个字典序最小的 LIS 方案。

## 问题 6：求最长上升子序列的关键点

!!! 题意

    给定长度为 $n$ 的整数序列 $a_1, a_2, \dots, a_n$，请你求出 LIS 中的一些关键点。关键点有如下两种定义：

    1. 如果一个元素可以在 LIS 中，则称其为关键点。
    2. 如果一个元素必须在 LIS 中，则称其为关键点。

对于定义 1，非常好求解：

- 如果以 $i$ 结尾的最长上升子序列和以 $i$ 开头的最长上升子序列能够拼接得到整个序列的 LIS，那么 $i$ 就是关键点。
- 以 $i$ 开头的最长上升子序列，可以把序列倒过来，求最长下降子序列。

对于定义 2，需要发散思维：

- 一个元素若可以出现在 LIS 中，那么它在所有 LIS 中的位置是相同的，这个位置就是求解 LIS 长度过程中的 $dp_i$。
- $i$ 是关键点等价于 $dp_i \ne dp_j(i \ne j)$。即在所有 LIS 方案中，某位置上只出现一个下标，那么它是关键点，反之亦然。
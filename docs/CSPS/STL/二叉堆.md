# 完全二叉树的存储

可以使用数组模拟链表的方式（记录左右儿子编号）来实现完全二叉树的存储。

```cpp
struct Node {
  int l, r;  // 左右儿子编号
} a[MAXN];
```

实际上可以按顺序给完全二叉树编号，此时编号为 $i$ 的结点的左儿子、右儿子、父亲编号为 $2i, 2i+1,\lfloor \frac{i}{2} \rfloor$。这种存储方式又被称为**堆式存储**。

<img src="二叉堆-1.jpg" style="zoom:25%;" />

# 堆

堆是一种支持动态快速查询最值的数据结构，支持以下几种操作：

- 高效插入元素。
- 高效查询、删除最值。
- 高效修改指定元素、删除指定元素.

二叉堆（简称堆）是一棵完全二叉树，它具有如下性质：

* 对于**小根堆**（**大根堆**）而言，父结点的值不大于（不小于）两个儿子的值。

堆的根又被称为堆顶，小根堆的堆顶元素是堆中最小的元素（如何证明？）。

可以使用数组直接存储堆。

```cpp
int a[MAXN], n;  // 数组存储堆，堆的大小，堆中的编号从 1 开始
```

<img src="二叉堆-2.jpg" style="zoom:25%;" />

## 基本操作

当对堆进行增删改查的操作时，可能会破坏堆的性质，也可能会让堆不再是完全二叉树，需要考虑如何维护。

下文先介绍两种基本操作：上浮和下沉。这两种操作用来保证堆的性质。本文讲解均以小根堆为例。

### 上浮

当你修改堆中某元素让其变小时：

* 如果元素有父亲，并且值比父亲更小，交换元素，然后继续执行该操作。
* 否则，停止上浮。

<img src="二叉堆-3.jpg" style="zoom:25%;" />

```cpp
// 让堆中编号为 x 的结点上浮
void Up(int x) {
  for (int i = x, j = i / 2; j && a[i] < a[j]; i = j, j = i / 2) {  // j 为父亲编号
    swap(a[i], a[j]);
  }
}
```

时间复杂度 $O(\log n)$。

### 下沉

当你修改堆中某元素让其变大时：

* 如果当前元素不是叶子，并且大于较小的儿子时，交换，然后继续执行该操作。
* 否则，停止下沉。

<img src="二叉堆-4.jpg" style="zoom:25%;" />

```cpp
// 获取较小儿子编号
int Son(int x) {
  int i = 2 * x, j = 2 * x + 1;
  return i + (j <= n && a[j] < a[i]);
}

// 让堆中编号为 x 的结点下沉
void Down(int x) {
  for (int i = x, j = Son(i); j <= n && a[i] > a[j]; i = j, j = Son(i)) {  // j 为较小儿子编号
    swap(a[i], a[j]);
  }
}
```

时间复杂度 $O(\log n)$。

### 查找最小值

即堆顶。

```cpp
int Top() {
  return a[1];
}
```

时间复杂度 $O(1)$。

### 插入元素

我们可以在完全二叉树的最后一个叶结点右边（即，堆的尾部）增加一个结点，保证堆仍然是一棵完全二叉树。

之后需要上浮来维护堆的性质。

<img src="二叉堆-6.jpg" style="zoom:25%;" />

```cpp
void Push(int x) {
  a[++n] = x;
  Up(n);
}
```

时间复杂度 $O(\log n)$。

### 删除最小值

如果直接删除堆顶，会使堆分裂为两个堆，而删除堆尾元素不需要维护。

我们可以将堆顶和堆尾元素进行交换，然后删除堆尾元素，保证堆仍然是一棵完全二叉树。

如果交换后的堆顶不满足堆的性质，需要进行下沉。

<img src="二叉堆-5.jpg" style="zoom:25%;" />

```cpp
void Pop() {
  swap(a[1], a[n--]);
  Down(1);
}
```

时间复杂度 $O(\log n)$。

# 用类来实现堆

对于比较复杂的数据结构，可以将其所存储的元素、属性、操作全部封装起来，使代码变得更具有逻辑。

```cpp
struct Heap {
  int a[MAXN], n;

  void Up(int x) {
    for (int i = x, j; (j = i / 2) && a[i] < a[j]; i = j) {
      swap(a[i], a[j]);
    }
  }

  int Son(int j) {
    return j + (j < n && a[j + 1] < a[j]);
  }

  void Down(int x) {
    for (int i = x, j; (j = Son(i * 2)) <= n && a[i] > a[j]; i = j) {
      swap(a[i], a[j]);
    }
  }

  void Push(int x) {
    a[++n] = x, Up(n);
  }

  void Pop() {
    swap(a[1], a[n--]);
    Down(1);
  }

  int Top() {
    return a[1];
  }
} h;
```

# priority_queue

优先队列，C++ 已经封装好的堆。比赛中常用优先队列代替堆的实现。

## 头文件

```cpp
#include <queue>
```

## 定义

```cpp
#include <vector>
#include <queue>
#include <functional>

// 定义时需要三个参数：数据类型为 TypeName，底层容器为 Container，比较器函数对象为 Compare
// 不指定 Container 和 Compare 时，默认底层容器为 vector，默认比较器规则为 less<TypeName>
priority_queue<TypeName, [Container], [Compare]> pq;

priority_queue<int> pq1;  // 默认为大根堆
priority_queue<int, vector<int>, greater<int>> pq3;  // 小根堆，需要引入头文件 <functional>
```

## 成员函数

$O(1)$ 时间复杂度：

* `top()` 访问堆顶元素（优先队列不能为空）
* `empty()` 判断容器是否为空
* `size()` 查询元素数量

$O(\log n)$ 时间复杂度：

* `push(x)` 插入元素
* `pop()` 删除堆顶元素（优先队列不能为空）

无 `clear()`，清空可以在局部定义容器，或者不断 `pop()`。

## 自定义比较器

对于结构体类型，我们需要定义其比较规则才能用优先队列维护该类型元素。

```cpp
struct Node {
  int x, id;
};
```

### 方法 1：定义比较器函数对象

```cpp
// 最一般的写法
struct cmp {
  bool operator()(const Node &i, const Node &j) const {  // 函数尾的 const 修饰符表示该函数不能对所在类的成员进行修改
    return i.x < j.x;
  }
};

priority_queue<Node, vector<Node>, cmp> pq;  // 定义了一个 x 为关键字的大根堆
```

### 方法 2：重载运算符

```cpp
bool operator<(const Node &i, const Node &j) {
  return i.x > j.x;
}

priority_queue<Node> pq;  // 定义了一个 x 为关键字的小根堆
```

```cpp
struct Node {
  int x, id;
  bool operator < (const Node &i) const {
    return x > i.x;
  }
};

priority_queue<Node> pq;  // 定义了一个 x 为关键字的小根堆
```

### 方法 3：使用 lamda 表达式（C++11）

```cpp
auto cmp = [](const Node &i, const Node &j) {
  return i.x < j.x;
};

priority_queue<Node, vector<Node>, decltype(cmp)) pq; // x 为关键字的大根堆
```

## 例子

```cpp
struct cmp{
  bool operator()(int i, int j) {
    return i > j;
  }
};

priority_queue<int> pq1;  // 默认为大根堆
priority_queue<int, vector<int>, cmp> pq2;  // 特别注意比较器的实现，跟 sort 比较器反着来

pq1.push(1);
pq1.push(2);
cout << pq1.top() << '\n';  // 2
pq1.pop();
cout << pq1.top() << '\n';  // 1

pq2.push(1);
pq2.push(2);
cout << pq2.top() << '\n';  // 1
pq2.pop();
cout << pq2.top() << '\n';  // 2
```

### 结构体

```cpp
struct Student {
  int a, b, c;  // 语数外
};

struct cmp {
  bool operator()(const Student &i, const Student &j) const {
    if (i.a != j.a) {
      return i.a < j.a;
    }
    if (i.b != j.b) {
      return i.b < j.b;
    }
    return i.c < j.c;
  }
};

priority_queue<Student, vector<Student>, cmp> pq;  // 按语数外从高到低排

int main() {
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  pq.push({100, 100, 90});
  pq.push({100, 100, 100});
  pq.push({100, 90, 100});
  pq.push({90, 100, 100});
  while (!pq.empty()) {
    Student x = pq.top();
    pq.pop();
    cout << x.a << ' ' << x.b << ' ' << x.c << '\n';
  }
  return 0;
}
```

# 应用

## 堆排序

### [【模板】快速排序](https://www.luogu.com.cn/problem/P1177)

没啥好讲解的。

堆排序不是稳定排序。平均、最坏、最好时间复杂度均为 $O(n \log n)$。

## 贪心

### [合并果子](http://ac.robo-maker.cn/p/P1353)

贪心，每次选出数目最小的两堆进行合并即可。暴力模拟是 $O(n^2)$，可以用优先队列优化至 $O(n \log n)$。

如果把合并过程建树，那么题目所要求的的答案就是 $\sum a_id_i$，$a_i$ 为数目，$d_i$ 为 $a_i$ 在树中的深度，显然 $d_i$ 大的叶子结点 $a_i$ 尽可能小，因此每次选出数目最小的两堆进行合并。

### [最小和](http://ac.robo-maker.cn/p/P1352)

堆优化。

如果暴力记录所有和，再加上排序，时间复杂度高达 $O(n^2 \log n)$。

我们可以先对 $n^2$ 个和进行分组：

* 第一组：$a_1 + b_1, a_1 + b_2, a_1 + b_3, \dots, a_1 + b_n$
* 第二组：$a_2 + b_1, a_2 + b_2, a_2 + b_3, \dots, a_2 + b_n$
* $\dots$
* 第 $N$ 组：$a_n + b_1, a_n + b_2, a_n + b_3, \dots, a_n + b_n$

由于题目给出的序列 $a$ 和 $b$ 都是单调不减的，我们发现每组内的 $n$ 个和也都是单调不减的。可以暴力用 $n$ 个指针维护每一组的最小值，每次取一个最小值 $O(n)$，总时间 $O(n^2)$。

设计状态【和，和所属的组，和在所属组中是第几个】。一开始先将每组的最小和的状态存储在堆中。每次取出堆中的最小和后，将该组的后一个和压入到堆中。执行 $n$ 次这样的操作，最小的 $n$ 个和就得到了。总时间 $O(n \log n)$。

为了方便实现，使用结构体表示状态，使用 priority_queue 代替堆。

### [建筑抢修](http://ac.robo-maker.cn/p/P1351)

堆贪心。贪心题目基本上是通过大量刷题攒经验和玄学构造来解决的，少数同学能用天赋加速大量刷题的过程。贪心的证明亦如此。

这个题状态有两个属性【修理时长，截止时刻】，可以先对截止时刻排序（相当于是给所有建筑定义了一个优先级，截止时间越早的肯定越要先完成）。

按排序后的顺序模拟修理建筑，并记录修理总时长。反例如下：

```
3
100 100
2 101
3 102
按此贪心只能修第 1 个建筑，实际能修第 2、3 个 建筑
```

如果总时长不超过当前建筑的截止时刻，那就把当前建筑加入到修理计划当中；

否则，说明必然有一个建筑是不能修理的（如何理解？），为了让后面的建筑修理有更多的时间，我们应该不去修理前面所有建筑中时长最长的那一个（如何理解？）。

可以用堆来存储所有修理建筑的时长，加入修理计划——堆中插入元素，移除时长最长的建筑——删除堆中最大值。

## 对顶堆（双堆维护分界线）

对顶堆。用两个相反的堆来对所有元素按值域进行划分。

我们可以设置两个堆，一个大根堆存储中位数左边一半（即较小部分）的所有元素（包括中位数），一个小根堆存储中位数右边一半（即较大部分）的所有元素。例如当前已有一个排序好的序列 $[A_1, A_2, A_3, A_4, A_5]$，那大根堆中存储 $[A_1, A_2, A_3]$，小根堆中存储 $[A_4, A_5]$。

我们发现：

* 堆的大小就是分界线的位置
* 堆顶元素就是分界线两端的元素
* 将一个堆顶元素移动到另一个堆中，就是调整分界线

### [动态中位数](http://ac.robo-maker.cn/p/P1350)

那么我们在插入元素时，可以根据该元素与两个堆顶的大小来决定他所应该插入的堆（仔细思考插入过程）。在查询中位数时，通过移动堆顶元素（如何移动？）调整分界线的位置，使得大根堆存储的元素数量为 $\frac{N + 1}{2}$（$N$ 为当前已插入的元素数量），此时大根堆的堆顶恰好就是中位数。

对于此题，可以按顺序的一个个插入元素，并且在奇数长度前缀的位置调整分界线。也可以每次插入元素时，就调整分界线的位置，可以证明每次分界线最多移动一个单位。

插入元素总时间 $O(n \log n)$，移动分界线总时间 $O(n \log n)$（为什么最多移动 $n$ 次？）

由于只需要存储值，使用 priority_queue 来实现。

# 习题

[CSP-J2020 直播获奖](https://www.luogu.com.cn/problem/P7072) 对顶堆

[P1801 黑匣子](https://www.luogu.com.cn/problem/P1801) 对顶堆

[P2085 最小函数值](https://www.luogu.com.cn/problem/P2085) 对顶堆，难

[P2949](https://www.luogu.com.cn/problem/P2949) 贪心

[[NOI2015] 荷马史诗](https://www.luogu.com.cn/problem/P2168) 贪心

[P2827 蚯蚓](https://www.luogu.com.cn/problem/P2827) 贪心，难

# 修改删除指定编号的元素

在堆中存储**元素的编号**（不是值），为每个元素记录它在**堆中的编号**，从而可以快速地查找、修改、删除指定元素。

```cpp
struct Element {
  int v;  // 值
  int p;  // 元素在堆中的编号
} e[MAXN];

struct Heap {
  int a[MAXN], n;  // 在堆中记录的是元素的编号，不再是值
  //...
};
```

在进行上浮、下沉操作交换元素时，也要交换元素在堆中的编号。

```cpp
void Swap(int i, int j) {        // 交换堆中位置i和j
  swap(a[i], a[j]);              // 交换元素
  e[a[i]].p = i, e[a[j]].p = j;  // 更新位置
}

void Up(int i) {  // 从位置i开始上浮
  // 有父亲且比父亲小
  for (int j = i / 2; j && e[a[i]].v < e[a[j]].v; i = j, j = i / 2) {
    Swap(i, j);  // 交换
  }
}

int Son(int j) {  // 与右兄弟取较优
  return j + (j < n && e[a[j + 1]].v < e[a[j]].v);
}

void Down(int i) {  // 从位置i开始下沉
  // 有儿子且比儿子要大
  for (int j = Son(i * 2); j <= n && e[a[i]].v > e[a[j]].v; i = j, j = Son(i * 2)) {
    Swap(i, j);  // 和儿子交换
  }
}
```

`priority_queue` 不支持以下操作，一般使用 `set` 或者 `map` 来完成这些操作。

## 修改指定编号的元素

查找到元素后可以直接修改。修改后的堆可能不满足性质，需要上浮或下沉操作。

```cpp
void Update(int i, int v) {
  e[i].v = v;
  Up(i), Down(i);
}

Update(e[x].p, v);  // 修改编号为 x 的元素值为 v
```

时间复杂度 $O(\log n)$。

## 删除指定编号的元素

与删除最值同理，在删除前先与堆尾元素进行交换。如果删除的不是堆尾，修改后的堆可能不满足性质，需要上浮或下沉（为何可能有上浮？）。

```cpp
void Delete(int i) {  // 删除位置i
  Swap(i, n);         // 与堆尾元素交换
  if (i <= --n) {     // 减少元素数量
    Up(i), Down(i);   // 调整位置i
  }
}

Delete(e[x].p);  // 删除编号为 x 的元素
```

时间复杂度 $O(\log n)$。

# C++ 语法扩展阅读

### 模板

```cpp
#include <iostream>

using namespace std;

template <class T>
T Calc(T a, T b) {
  return a + b;
}

int main() {
  int a = 5, b = 10;
  double c = 1.2, d = 3.6;
  cout << Calc(a, b) << ' ' << Calc(c, d);
  return 0;
}
```

### greater\<int\>

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>

using namespace std;

int main() {
  vector<int> v{1, 3, 5, 7, 9};
  sort(v.begin(), v.end(), greater<int>());
  for (auto x : v) {
    cout << x << ' ';
  }
  return 0;
}
```

实际上它就是一个这样的函数对象：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>

using namespace std;

template <class T>
struct Gr {
  bool operator()(const T &i, const T &j) {
    return i < j;
  }
};

int main() {
  vector<int> v{1, 3, 5, 7, 9};
  sort(v.begin(), v.end(), Gr<int>());
  for (auto x : v) {
    cout << x << ' ';
  }
  return 0;
}
```

## 参考

可以用命名空间来区分不同的程序依次达到获取更多暴力分的效果。

1. [c++优先队列priority_queue（自定义比较函数）](https://jutou.blog.csdn.net/article/details/122128445?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-122128445-blog-47099215.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-122128445-blog-47099215.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=1)
2. [priority_queue 的参考手册](https://en.cppreference.com/w/cpp/container/priority_queue)
3. [c++ lambda 表达式](https://oi-wiki.org/lang/lambda/)
4. [c++ template 模板](https://blog.csdn.net/fuhanghang/article/details/112563711)
5. [关于greater＜int＞以及类模板的一些理解](https://blog.csdn.net/hututufandou/article/details/104260496/)
6. [骗分 1](https://blog.csdn.net/ImNot6Dora/article/details/126788076)
7. [骗分 2](https://www.cnblogs.com/lzexmpoane/p/15430614.html)
8. [骗分 3](https://www.luogu.com.cn/blog/DJCreeper/special-program)
9. [【洛谷日报#86】NOIP选手必知的编程技巧](https://zhuanlan.zhihu.com/p/50780950)


# 区间 DP

区间 DP 是一类在序列上求解最优值、方案数等问题的总称，并且这些问题通常具有如下性质：

- 我们可以将区间 $[l, r]$ 对应的问题分解为若干个不相交的连续小区间的问题，通常是分成一个前缀 $[l, i]$ 和一个后缀 $[i, r]$。
- 可以独立地解决出每个小区间的问题，然后将小区间答案用于求解原区间的答案。
- 每种区间分解的方法对应了不同的转移，可以发现拓扑序是小区间到大区间（即区间长度从小到大）。
- 状态总数为区间数量 $O(n^2)$。
- 简单的区间 DP 一般来说时间复杂度为 $O(n^3)$，可以通过 $n = 500$ 的数据范围来猜测出解法（根据数据范围猜测算法可以打出一些题目的暴力分）。
- 一维序列上的区间 DP 有两种常见模型：两端取，中间分。
- 区间 DP 很讲究贪心构造、分治、拓扑序、初始状态边界。
  
（强调拓扑序，分治，不强调最优化属性和最优子结构）

对于区间 DP 中的最优化问题，一般每个区间都只会保留最优状态，并且满足最优子结构性质，所以不会刻意强调这一点。

## 洛谷 P1435 回文串

!!! 题意

    给定一个字符串 $S$，计算至少插入几个字符使得 $S$ 是回文串。$|S| \le 1000$。

考虑回文的定义：$S_i = S_{n + 1 - i}$，其中 $n = |S|, 1 \le i \le n$。

贪心：令答案字符串为 $T$，则 $T$ 的首尾字符相同，并且 $T$ 的首字符为 $S_1$ 或者 $T$ 的尾字符为 $S_{n}$。

- 请思考原因。

基于这个思维，我们可以动手推导出一些简单的事实：

- 如果 $S[1] == S[n]$，我们只需要把 $S[2] \dots S[n - 1]$ 变为回文串。
- 如果 $S[1] \ne S[n]$，有两种构造回文串的方法：
    - 在 $S$ 的尾部插入 $S[1]$，然后把 $S[2] \dots S[n]$ 变为回文串。
    - 在 $S$ 的头部插入 $S[n]$，把 $S[1] \dots S[n - 1]$ 变为回文串。
- 继续推导下去，可以发现明显的分治结构。

（画图演示）

可以发现，我们将原字符串的问题，分解为了一个长度为 $n - 2$ 或 $n - 1$ 的子串问题，我们可以用暴搜（暴力分治）、记忆化或者循环 DP 的方式来实现。

本题拓扑序，除了区间从小到大以外，还有别的实现方法，请思考。

### 暴搜（暴力分治）

!!! 暴搜

    ```cpp
    void dfs(int i, int j, int cnt) {
      if (i >= j) {
        ans = min(ans, cnt);
        return ;
      }
      if (s[i] == s[j]) {
        dfs(i + 1, j - 1, cnt);
      } else {
        dfs(i + 1, j, cnt + 1), dfs(i, j - 1, cnt + 1);
      }
    }
    ```

!!! 分治

    ```cpp
    // dfs(i, j) 表示让 s[i] ... s[j] 变为回文串的最少插入次数
    int dfs(int i, int j) {
      if (i >= j) {
        // i == j：只剩下一个字符
        // i > j：最后剩下两个字符且相同，(i, i + 1) -> (i + 1, i)
        return 0;
      }
      if (s[i] == s[j]) {
        return dfs(i + 1, j - 1);
      }
      return min(dfs(i + 1, j), dfs(i, j - 1)) + 1;
    }
    ```

时间复杂度为 $O(2^n)$。

- 请分析。

### 记忆化搜索

使用记忆化优化分治，因为状态转移存在拓扑序：区间长度从小变大。

```cpp
// dfs(i, j) 表示让 s[i] ... s[j] 变为回文串的最少插入次数
int dfs(int i, int j) {
  if (i >= j) {
    // i == j：只剩下一个字符
    // i > j：最后剩下两个字符且相同，(i, i + 1) -> (i + 1, i)
    return 0;
  }
  if (dp[i][j] != -1) {  // 每个状态只被计算一次
    return dp[i][j];
  }
  if (s[i] == s[j]) {
    return dp[i][j] = dfs(i + 1, j - 1);
  }
  return dp[i][j] = min(dfs(i + 1, j), dfs(i, j - 1)) + 1;
}
```

状态数 $O(n^2)$，每个状态最多两次转移，总时间复杂度 $O(n^2)$。

### 循环 DP

```cpp
for (int i = 0; i < n; i++) {
  dp[i][i] = 0;  // 只有一个字符时
}
for (int i = 0; i < n - 1; i++) {
  dp[i][i + 1] = s[i] != s[i + 1];  // 只有两个字符
}
for (int len = 3; len <= n; len++) {                   // 枚举长度拓扑序
  for (int i = 0, j = i + len - 1; j < n; i++, j++) {  // 枚举区间左右端点
    if (s[i] == s[j]) {
      dp[i][j] = dp[i + 1][j - 1];
    } else {
      dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1;
    }
  }
}
```

还有其他的拓扑序、边界初始化方法。

??? 代码

    === "代码 1"

        ```cpp
        for (int i = 1; i <= n; i++) {
          dp[i][i] = 0;      // 长度为 1 的区间
          dp[i + 1][i] = 0;  // 长度为 0 的区间
        }

        for (int len = 2; len <= n; len++) {  // 拓扑序：区间长度从小到大
          for (int i = 1, j = len; j <= n; i++, j++) {
            if (s[i] == s[j]) {
              dp[i][j] = dp[i + 1][j - 1];
            } else {
              dp[i][j] = min(dp[i][j - 1] + 1, dp[i + 1][j] + 1);
            }
          }
        }
        ```

    === "代码 2"

        ```cpp
        for (int len = 2; len <= n; len++) {  // 拓扑序：区间长度从小到大
          for (int i = 1, j = len; j <= n; i++, j++) {
            if (s[i] == s[j]) {
              dp[i][len] = dp[i + 1][len - 2];
            } else {
              dp[i][len] = min(dp[i][len - 1] + 1, dp[i + 1][len - 1] + 1);
            }
          }
        }
        ```
    
    === "代码 3"

        ```cpp
        for (int i = n; i >= 1; i--) {  // 拓扑序：i 从大到小，i 相同时 j 从小到大
          for (int j = i; j <= n; j++) {
            if (s[i] == s[j]) {
              dp[i][j] = dp[i + 1][j - 1];
            } else {
              dp[i][j] = min(dp[i][j - 1] + 1, dp[i + 1][j] + 1);
            }
          }
        }
        ```

状态数 $O(n^2)$，每个状态最多两次转移，总时间复杂度 $O(n^2)$。

## 洛谷 P1775 石子合并（序列版）

!!! 题意

    有 $N$ 堆石子排成一列，第 $i$ 堆石子数为 $A_i$。每次可以将相邻两堆石子合并，代价为这两堆石子的数量和。求出将 $N$ 堆石子合并为一堆的最小代价。

思维：可以发现，在任意一种合并过程中出现的任意一个石子堆，都是由原来 $N$ 堆石子中一段连续的堆合并而成的。

我们有以下两种方法模拟石子合并的过程：

1. 正着合并石子堆，记录每堆石子的数量，用搜索来实现。（正着模拟操作的视角）
2. 倒着拆分石子堆，用分治来实现。（倒着撤销操作的视角）

我们先给出正着合并石子堆的伪代码，这是需要掌握的，当你不会 DP、推不出结论时就要写暴搜。

- 状态是石子堆序列，转移是合并两堆得到新的石子堆序列。

```cpp
vector<int> stone;

void dfs(int cost) {
  if (stone.size() == 1) {
    ans = min(ans, cost);
    return ;
  }
  for (int i = 0; i < stone.size() - 1; i++) {
    int x = stone[i], y = stone[i + 1];
    stone[i] = x + y;
    stone.erase(stone.begin() + i + 1);
    dfs(cost + x + y);
    stone.insert(stone.begin() + i + 1, y);
    stone[i] = x;
  }
}

for (int i = 1; i <= n; i++) {
  stone.push_back(A[i]);
}
dfs(0);
```

时间复杂度：$O(N! \times N)$，用链表优化插入删除，时间复杂度优化为 $O(N!)$。

正着合并石子堆，发现没有什么可以优化的空间（这里说的正着是指视角，后续你会发现可以正着循环 DP）。

考虑倒着的视角，用记忆化或者循环 DP 实现。

对于 DP，状态数 $O(n^2)$，每个状态最多转移 $O(n)$，总时间复杂度 $O(n^3)$。更仔细的时间复杂度分析见下：

- 长度为 $i$ 的区间有 $n + 1 - i$ 个。
- 长度为 $i$ 的区间有 $i - 1$ 个分段点对应的转移。
- 状态求解总数为 $O(n^2)$，转移次数 $\sum \limits_{i = 1}^n (n + 1 - i)(i - 1) = O(n^3)$。

### 记忆化优化分治

就不给出纯分治的指数级别时间复杂度的代码了。

```cpp
// dfs(i, j) 把第 i 到 j 堆石子合并的最小代价
int dfs(int l, int r) {
  if (l == r) {
    return 0;
  }
  if (dp[l][r] != -1) {
    return dp[l][r];
  }
  dp[l][r] = INT_MAX;
  for (int k = l; k < r; k++) {                           // 枚举最后一次合并的分段点
    dp[l][r] = min(dp[l][r], dfs(l, k) + dfs(k + 1, r));  // 独立求解子问题
  }
  return dp[l][r] += s[r] - s[l - 1];  // 最后一次合并的代价
}

for (int i = 1; i <= n; i++) {
  s[i] = s[i - 1] + a[i];
}
int ans = dfs(1, n);
```

### 循环 DP

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int MAXN = 1e3 + 1, INF = 1e9;

int n, a[MAXN], sum[MAXN], dp[MAXN][MAXN];

int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
    sum[i] = sum[i - 1] + a[i];
  }
  fill(dp[1], dp[n] + n + 1, INF);
  for (int i = 1; i <= n; i++) {
    dp[i][i] = 0;
  }
  for (int len = 2; len <= n; len++) {
    for (int i = 1, j = len; j <= n; i++, j++) {
      for (int k = i; k < j; k++) {
        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + sum[j] - sum[i - 1]);
      }
    }
  }
  cout << dp[1][n];
  return 0;
}
```

`INF` 的设置，每堆石子最多参与到 $N - 1$ 次合并中，因此 `INF` 至少为 $(N - 1) \times \sum A_i$。

## 洛谷 P1063 能量项链

!!! 题意

    给定一个环形序列，每个元素由头、尾标记 $a_i, b_i$，聚合两颗相邻珠子会释放能量 $a_i * b_i * b_{i + 1}$，聚合后的珠子的头尾标记为 $a_i, b_{i + 1}$。求 $n - 1$ 次聚合后总释放能量的最大值。

### 断环成链

枚举断环成链的位置，每次断开后做一次区间 DP。总时间复杂度 $O(n^4)$。

```cpp
for (int x = 0; x < n; x++) {           // 枚举断点位置
  for (int i = 0, y = x; i < n; i++) {  // 断环成链
    b[i] = a[y];
    y = (y + 1) % n;
  }
  fill(dp[0], dp[n - 1] + n, 0);
  // 区间 dp
  //......
  ans = max(ans, dp[0][n - 1]);
}
```

### 把环拆成两倍长度的链

将换断为两倍长度的链，在这上面做区间 DP，时间复杂度 $O(n^3)$。

```cpp
for (int i = 0; i < n; i++) {
  cin >> a[i];
  a[i + n] = a[i];
}
for (int len = 2; len <= n; len++) {
  for (int i = 0, j = i + len - 1; j < 2 * n; i++, j++) {
    
  }
}
```

## CF 607B Zuma

!!! 题意

    给定一个长度为 $N$ 的序列 $A$，每次可以选择一个回文子段并移除，剩下元素依次排列形成一个新序列。请你求出最少多少次操作使得序列为空。$|A| \le 500$。

猜测是 $O(N^3)$ 的算法。

显然我们可以写一个正着视角的暴搜，发现没有什么优化空间。

- 状态是序列，转移是移除一个回文子段并重新拼接序列。

用倒着的视角看问题，考虑最后一次和倒数第二次移除的子段分别为 $S$ 和 $T$，我们发现这两个子段的位置关系有两种：

1. `ST` 或者 `TS`。
2. `S` 中间插入了 `T`，即 `S` 的前缀 + `T` + `S` 去除前缀的剩余序列，令该序列为 $str$。

定义 $dp_{i, j}$ 表示移除 $a_i \dots a_j$ 的最少操作次数。

对于第一种位置关系，我们直接枚举分段点做转移就好了。$dp_{i, j} = \min \limits_{i \le k \lt j} \{ dp_{i, k} + dp_{k + 1, j} \}$

对于第二种情况，我们发现 $str$ 的首尾元素一定相同。$dp_{i, j} = dp_{i + 1, j - 1}$，可以把 $[i + 1, j - 1]$ 最后一次消掉的回文子段 $X$ 与 $a_i$ 和 $a_j$ 拼成一个新的回文子段，`a[i] + X + a[j]`。

状态总数 $O(N^2)$，每个状态转移时间 $O(N)$，总时间复杂度 $O(N^3)$。

## 更多习题

### 洛谷 P3146

??? 思路

    我们关注每一段区间是否最终能合并为一个数值。

    令 $dp[i][j]$ 表示区间 $[i, j]$ 最终合并而成的数值，如果不能合并，则 $dp[i][j] = 0$。

    转移类似于石子合并，枚举合并前的断点 $k$，$dp[i][k] == dp[k + 1][j]$ 时，$dp[i][j] = dp[i][k] + 1$。

### 洛谷 P2858 treats for the cow

类似于回文字串。

### 洛谷 P1880 石子合并（环型）

类似于能量项链。

### 洛谷 P4170 染色

类似于 Zuma。




# floyd——全源最短路

洛谷 B3647。$N \le 500$。

## 一些性质

对于两个点之间的最短路径 $P$，在 $P$ 上任意两个点之间的路径（$P$​ 的子路径）长度一定是该两点的最短路径长度。

两点之间的长的最短路径可以分解为两条短的最短路径组成，通过枚举中间结点的方式来确定这两条短路径（分治思想）。

## floyd

floyd-warshall 算法用于求出任意两个点之间的最短路，其本质是动态规划。

令 $D(k, i, j)$ 表示经过若干编号不超过 $k$ 的点（不包括起点和终点）、从起点 $i$ 走到终点 $j$ 的最短路径长度。特别地，$D(0, i, j)$ 可以表示初始时 $i \to j$ 的边。没有自环时，$D(0, i, i) = 0$。其他状态 $D(k, i, j) = + \infty$。

从小到大枚举 $k$ 进行分治。

考虑转移，从 $i$ 到 $j$ 且经过若干编号超过 $k$ 的点的路径包含两类：中间经过 $k$ 的路径，和中间经过的点 $< k$ 的路径。

- 对于后者，最短路径的长度就是 $D(k - 1, i, j)$。
- 对于前者，$i$ 到 $j$ 的路径分为两部分：$i$ 到 $k$ 的路径 和 $k$ 到 $j$ 的路径，此时的最短路径长度为 $D(k - 1, i, k) + D(k - 1, k, j)$​。
- 这里的转移是在一系列边组成的路径上行走，而不是一条边。

拓扑序为 $k$ 从小到大，枚举拓扑序和状态进行转移即可。时空复杂度均为 $O(N^3)$。

```cpp
for (int i = 1; i <= m; i++) {
  cin >> u >> v >> w;
  D[0][u][v] = w;
}
for (int k = 1; k <= n; k++) {
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
      D[k][i][j] = min(D[k - 1][i][j], D[k - 1][i][k] + D[k - 1][k][j]);
    }
  }
}

// D[n][i][j] 就是 i 到 j 在图上的最短路径长度
```

求出所有的 $D(k - 1, i, j)$ 和 $D(k, i, j)$ 时，发现 $D(k - 1, i, k) = D(k, i, k), D(k - 1, k, j) = D(k, k, j)$，因此可以直接将第一个维度滚动优化去掉，空间复杂度降为 $O(N^2)$。

```cpp
for (int k = 1; k <= n; k++) {  // 动态规划：拓扑序；图论角度：一条最短路径上的中间点。
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
      D[i][j] = min(D[i][j], D[i][k] + D[k][j]);
    }
  }
}
```

### 本质

floyd 的本质是动态规划。其转移通式如下：

- 状态：$dp[i][j][k]$ 表示从 $i$ 走到 $j$ 中途只允许走 $[1,k]$ 的路径值（根据问题设定）。
- 转移：$dp[i][j][k] = best(dp[i][j][k - 1],merge(dp[i][k][k - 1],dp[k][j][k - 1]))$。
- 初始：根据问题设定。
- 解释：$best$ 为两种不同路径值的转移方法，$merge$ 为两段路径拼接后的路径值计算方法。
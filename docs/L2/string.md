# string 的成员函数

## 为什么要使用 string

用字符数组实现字符串是有许多不便的：

- 受限于数组的语法设计，不能直接对字符串直接赋值、复制、拼接。
- 无法直接比较字符串的字典序大小，需要调用 `strcmp` 函数。

`std::string` 是在标准模板库（Standard Template Library）的头文件 `<string>` 中提供的一个已封装好的字符串类：
- `string` 能动态分配空间，无需预先指明字符串的长度。
- 将一些常用功能封装为成员函数。
- 体现了 C++ 面向对象的编程特性。

## 常规使用

```cpp
string s, t = "abc";  // 声明，初始化
cin >> s;             // 可以直接输入
t[0] = 'z';           // 支持下标访问
cout << a;            // 直接输出字符串中的内容
```

`string` 支持类似数组的方式通过下标来存取空间，并且可以直接输入输出。输入时默认以空白字符为分隔符。

## getline()

使用 `getline(cin, a)` 将一整行字符串读入，以换行符为分隔符。

```cpp
string s;
getline(cin, s);
```

## 运算符重载

### 赋值运算符

```cpp
string s, t;
char a[10] = "abc";
s = "123";  // 赋值
t = s;      // 赋值
t = a;      // 建议不要将字符数组的字符串赋值给 `string` 变量
```

### 关系运算符

`>`、`<`、`>=`、`<=`、`==`、`!=`，对两个 `string` 之间进行字典序比较。

```cpp
string x = "123", y = "156";
cout << (x < y) << '\n';
string a = "45", y = "123";
cout << (a < b) << '\n';
```

时间复杂度为 $O(n)$，其中 $n$ 为字符串的长度。

### 加法运算符

可以拼接两个 `string` 变量。

```cpp
string s = "123", t = "456";
cout << s + t << '\n';  // 123456，时间复杂度 O(n)
t += s;                 // 时间复杂度 O(n)
cout << t << '\n';      // 456123
```

也可以在一个 `char` 和 `string` 之间进行拼接。

```cpp
string s = "abc";
s += 'z';           // 时间复杂度 O(1)
cout << s << '\n';  // abcz
cout << 'z' + s;    // zabcz，时间复杂度 O(n)
```

### 常用成员函数

定义 `string s, t`，令他们两个字符串的长度分别为 $n$ 和 $m$。

| 成员函数             | 功能                                              | 时间复杂度                 |
| -------------------- | ------------------------------------------------- | -------------------------- |
| s.size(), s.length() | 返回 s 的长度                                     | $O(1)$                     |
| s.empty()            | 返回 s 是否为空串                                 | $O(1)$                     |
| s.clear()            | 清空字符串，s 变为空串                            | $O(n)$                     |
| s.push_back(x)       | 将字符变量 x 的内容添加到 s 的尾部                | $O(1)$                     |
| s.pop_back()         | 删除 s 的最后一个字符                             | $O(1)$                     |
| s.substr(pos)        | 返回从 s[pos] 到 s 的最后一个字符构成的子串       | $O(len)$，$len$ 为子串长度 |
| s.substr(pos, len)   | 返回从 s[pos] 开始的长度为 len 的子串             | $O(len)$，$len$ 为子串长度 |
| s.insert(pos, t)     | 在 s[pos] 之前插入字符串 t                        | $O(n + m)$                 |
| s.find(t)            | 查找 t 在 s 中作为子串的第一次出现的位置          | 最好 $O(m)$，最坏 $O(nm)$  |
| s.find(t, pos)       | 查找 t 在 s[pos] 及之后作为子串的第一次出现的位置 | 最好 $O(m)$，最坏 $O(nm)$  |
| s.erase(pos, len)    | 删除从 s[pos] 开始的连续的 len 个字符             | O(n)                       |

对于 `.find()`，如果查找不到相应子串，返回常量 `string::npos`，将其强制转化为 `int` 类型后结果为 `-1`。

对于 `.substr(pos, len)`，如果所求的子串长度已经超出最后一个字符，即 $pos + len \ge n$，则其等同于 `.substr(pos)`；如果 $pos \ge n$，报 `RE` 错误。

一般来说，`.insert()`、`.erase()`、`.find()`、`.substr()` 在信息学中不常用，因为在给定数据规模下很有可能超时，但必须掌握，可以用来写超时暴力。

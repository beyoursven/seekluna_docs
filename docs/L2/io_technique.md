# 输入技巧

## cin

`cin` 使用**空白字符**作为数据之间的分隔符，空白字符包含空格符、制表符、换行符。使用 `cin >> ` 方式读取数据时不会将空白字符当做数据处理。观察下面几个例子。

```cpp
int a, b;
cin >> a >> b;
cout << a << ' ' << b;

// 输入 2 3，输出 2 3
// 输入 2 回车 3，输出 2 3
```

`cin` 在遇到无法匹配的字符时会自动分隔。

```cpp
int a;
char c;
cin >> a >> c;  // 输入 12?
cout << a << ' ' << c;  // 输出 12 ?
```

`cin` 在读入字符型时不必使用分隔符。

```cpp
char a, b;
cin >> a >> b;
cout << a << ' ' << b;

// 输入 ac，输出 a c
// 输入 a c，输出 a c
// 输入 a 回车 c，输出 a c
```

读入数据失败时，`cin` 会获得**失效标记**。`cin` 失效后无法再使用 `cin` 进行任何读入。可以将 `cin` 转为 bool 类型来查看是否失效。

```cpp
int a = 1, b = 2;
char c = '!';
cin >> a >> b >> c; // 输入 67?89
cout << (bool)cin << ' ' << a << ' ' << b << ' ' << c;  // 输出 0 67 0 !
```

可以使用 `while (cin >> )` 的方式连续读取若干输入直到输入结束或者输入出现错误。

```cpp
int sum = 0;
while (cin >> x) {
  sum += x;
}

// 输入 3 4 5 回车，然后按 ctrl + z，然后回车，输出 12
```

`cin.putback(c)` 可以将字符 `c` 弹回到输入缓冲区中。

```cpp
int a;
cin.putback('1');
cin >> a; // 输入 2
cout << a;  // 输出 21
```

我们可以利用 `cin.putback()` 帮助我们，当我们不确定是否要读入整数时，可以先读入一个字符进行检查，如果为整数，则弹回然后重新读入整数。

```cpp
char ch;
int x;
cin >> ch;
if (ch >= '0' && ch <= '9') {
  cin.putback(ch);
  cin >> x;
}
```

`cin.get()` 函数可以用来读取包括空白字符在内的字符。用法为 `cin.get(char 变量名)` 或者 `变量名 = cin.get()`。

```cpp
char a, b, c;
cin.get(a);
b = cin.get();
cin >> c;
cout << a << b << c;

// 输入 2 3
// 输出 2 3
```

关于 `cin` 的失效标记和 `while (cin >> )` 的原理，以下是 GPT-4 的回答。

??? GPT-4 问答

    === "while (cin >> x) 的原理是什么？"

        在 C++ 中，使用 `while (cin >> x)` 循环是一种常见的方式，用于连续读取输入直到遇到输入结束或错误。这个语句的工作原理基于 `cin` 的状态，具体解释如下：

        1. **输入运算符（`>>`）**：当 `cin >> x` 被执行时，C++ 尝试从标准输入（通常是键盘输入）读取数据，并将其存储在变量 `x` 中。类型必须与变量 `x` 的类型匹配，否则会导致错误。

        2. **循环条件**：`while` 循环的条件是 `cin >> x` 的结果。在 C++ 中，`cin >> x` 实际上返回 `cin` 对象的引用。当输入成功时（即数据成功读入并且类型匹配），`cin` 保持在有效状态（未设置 `failbit` 或 `badbit`），并被视为一个真值。如果遇到输入错误（例如类型不匹配或输入流结束），`failbit` 或 `badbit` 将被设置，`cin` 对象会转换为假值，因此终止循环。

        3. **处理不匹配或错误**：如果输入的数据与 `x` 的类型不匹配，`cin` 的状态将变为错误状态，这导致 `while` 循环终止。例如，如果期望的是一个整数，但用户输入了一些字母，`cin` 将不能将这些字母解释为整数，从而设置 `failbit`。

        4. **结束输入**：在 Unix/Linux 系统中，可以通过 Ctrl+D（文件结束符 EOF）来表示输入结束，在 Windows 系统中通常使用 Ctrl+Z。这会使 `cin` 进入文件结束状态（设置 `eofbit`），同时如果没有更多的有效数据，也会设置 `failbit`，从而停止循环。

        这种 `while (cin >> x)` 结构非常适合于需要多次读取同类型数据的情况，例如输入一系列数字。当数据正确输入时，循环继续；当遇到不符合要求的输入或输入结束时，循环停止，允许程序继续执行后续操作。

    === "cin 流状态是什么？"

        在 C++ 中，`cin` 流状态指的是一个输入流的当前状态，这些状态可以帮助开发者了解是否发生了输入错误或其他类型的流问题。C++ 标准库中的输入流对象（如 `cin`）使用状态标志来表示流的当前健康状况。以下是一些常见的 `cin` 流状态标志：

        5. **goodbit**: 如果设置了 `goodbit`，表示流未发生错误，状态良好。这是默认状态，没有设置其他任何错误标志时，`goodbit` 会被设置。

        6. **eofbit**: 如果在读取期间到达了输入的末尾，将设置 `eofbit`。例如，如果你尝试从文件中读取但已经达到了文件的末尾，就会发生这种情况。

        7. **failbit**: 如果因为预期格式外的字符或其他原因导致输入操作失败，则会设置 `failbit`。例如，如果期望输入一个整数，但用户输入了一个字母，就会设置 `failbit`。

        8. **badbit**: 如果在读写操作中发生错误，如不可恢复的流错误或设备故障，将设置 `badbit`。设置 `badbit` 通常意味着流不能继续使用。

        你可以使用几种方法来检查这些状态标志：
        * `cin.good()` 检查 `goodbit`，如果流状态良好，即没有错误，返回 `true`。
        * `cin.eof()` 检查 `eofbit`，如果达到输入末尾，返回 `true`。
        * `cin.fail()` 检查 `failbit` 或 `badbit`，如果任一错误标志被设置，返回 `true`。
        * `cin.bad()` 检查 `badbit`，如果设置了 `badbit`，返回 `true`。

        这些函数允许开发者在进行进一步的输入操作之前验证流的状态，从而在处理输入时做出适当的错误处理。

## getline

我们可以使用 `getline()` 函数按行读入一整行字符串到 `string` 变量中，用法为 `getline(cin, string 变量名);`。`getline()` 默认以换行符为分隔符。

```cpp
string a;
getline(cin, a);
cout << a;

// 输入 123 abc
// 输出 123 abc
```

调用 `getline()` 函数会将输入缓冲区中直到第一个换行符（包括换行符）的内容全部弹出。在调用 `getline()` 函数之前，一定要保证之前的换行符一定不在输入缓冲区中。

```cpp
int x;
string s;
cin >> x;
getline(cin, s);

// 输入 2，回车，程序立马结束
// 应该在 cin >> x; 之后立马跟一个 
```
# 贪心

贪心算法（greedy algorithm），是模拟一个【贪婪的】人做决策的方式：每一步的选择和决定在当前时刻看来都是最优的。贪心算法只关心当前的选择是否是当前最优，而不考虑对未来的影响，并且一般也不会撤销以前做出的决定。这种【直接的】、【不犹豫的】做决定的方式，体现了贪心算法是一个非常高效率的算法。

## 一些性质和证明

设计贪心算法的难点在于设计一个正确的贪心策略，使得一定能够得到全局的最优解。

一般来说，一个正确的贪心算法需要满足两个性质：

- 最优子结构性质：一个问题的最优解包含子问题的最优解。
- 贪心选择性质：贪心策略只考虑已经做过的所有决策，不考虑未来情况，并且可以从不断的【局部的最优解】得到【全局的最优解】。

证明贪心算法的正确性，可以用到很多数学方法：反证法、数学归纳法、构造法等等。

## 如何在 J 组理解贪心

上面讲的都太学术了，很难理解。

在 J 组，可以将贪心算法理解成【设计一个贪心策略】并且【对贪心策略进行模拟】。由于现在的你证明贪心算法比较困难，不妨把贪心当做一种训练思维和第六感的工具:>

下面会给出一些经典的例子来帮助你理解【贪心策略】，而其中的正确性我们不会给出严谨的数学证明。

## 例题

### 逐月 P1597 纸币问题 I

!!! 题意

    用若干张 $1, 5, 10, 20, 50, 100$ 元的人民币纸币凑出 $n$ 元。求所用纸币张数最小值。

贪心策略：优先使用面值更大的人民币。

例如，为了凑出 $287$ 元，你需要使用 $2$ 张 $100$ 元、$1$ 张 $50$ 元、$1$ 张 $20$ 元、$1$ 张 $10$ 元、$1$ 张 $5$ 元、$2$ 张 $1$ 元纸币。在感觉上也能理解这样的策略所使用的的纸币张数一定最少。

将这样的贪心策略模拟实现即可。

??? 模拟步骤

    1. 首先计算出 $100$ 元的张数为 $[\frac{n}{100}]$，剩余钱数变为 $n \gets n \bmod 100$。
    2. 然后计算出 $50$ 元的张数为 $[\frac{n}{50}]$，剩余钱数变为 $n \gets n \bmod 50$。
    3. $\dots$

??? 代码

    ```cpp
    #include <bits/stdc++.h>

    using namespace std;

    const int a[] = {100, 50, 20, 10, 5, 1};

    int n, ans;

    int main() {
      cin >> n;
      for (int i = 0; i < 6; i++) {  // 贪心地优先使用大面值纸币凑钱
        ans += n / a[i];             // 计算纸币张数
        n %= a[i];                   // 计算剩余钱数
      }
      cout << ans;
      return 0;
    }
    ```

但这样地贪心策略一定是正确的吗？请见本笔记的最后一题。

### 逐月 P1599 数列分段

!!! 题意

    给你 $N$ 个正整数构成的序列，你要将其划分为若干个子段，每个元素都在恰好一个子段中，并且每个子段的数字和不超过 $M$。求最少分段数。

贪心策略：从前往后考虑每个数字，【尽量不分段】，这意味着如果数字能放进当前子段中就放，否则新建一个子段。

这样的策略也很好理解，尽量不分段，意思就是分段数量最少。

模拟实现即可。

??? 模拟步骤和时间复杂度
    
    定义变量 $sum$ 和 $cnt$ 记录当前子段和以及子段数量。

    对于 $i = 1, 2, \dots, N$ 的每个数字 $A_i$：

    - 如果当前数字能放进当前子段，即 $sum + A_i \le M$，那么直接放入，然后更新 $sum \gets sum + A_i$
    - 否则新开一个子段，更新 $cnt \gets cnt + 1, sum \gets A_i$

    时间复杂度 $O(N)$。

??? 代码

    ```cpp
    #include <bits/stdc++.h>

    using namespace std;

    const int MAXN = 1e5 + 1;

    int n, m, a[MAXN];

    int main() {
      ios::sync_with_stdio(0), cin.tie(0);
      cin >> n >> m;
      for (int i = 1; i <= n; i++) {
        cin >> a[i];
      }
      int cnt = 1, sum = 0;  // 已分段数，当前段的数字之和
      for (int i = 1; i <= n; i++) {
        if (sum + a[i] <= m) {  // 当前数字能放在当前段
          sum += a[i];          // 贪心地将当前数字放在当前段
        } else {
          sum = a[i], cnt++;  // 新开一段
        }
      }
      cout << cnt << '\n';
      return 0;
    }
    ```

### 逐月 P1275 超级书架

!!! 题意

    给定 $N$ 头奶牛的高度，选出尽可能少的奶牛，使得选出的奶牛的身高之和大于 $S$。

贪心策略：优先选择高度大的奶牛。

这种策略的正确性也非常的直观：一个高度大的奶牛可以代替多个高度低的奶牛。

学习完 `sort` 排序，相信你这道题一定能做出。

??? 步骤和时间复杂度

    将所有奶牛的高度进行 `sort` 排序
    
    按身高从高到低的顺序不断选出奶牛，直到身高之和大于 $S$。

    时间复杂度 $O(N \log N)$。

??? 代码

    ```cpp
    #include <algorithm>
    #include <iostream>

    using namespace std;

    const int MAXN = 2e5 + 1;

    int n, b, h[20010];

    bool cmp(int i, int j) {
      return i > j;
    }

    int main() {
      cin >> n >> b;
      for (int i = 1; i <= n; i++) {
        cin >> h[i];
      }
      sort(h + 1, h + n + 1, cmp);
      int sum = 0, ans = 0;
      for (int i = 1; i <= n; i++) {
        sum += h[i];
        if (sum >= b) {
          ans = i;
          break;
        }
      }
      cout << ans;
      return 0;
    }
    ```

### 逐月 P1603 象棋比赛

!!! 题意

    给定 $N$ 个人的能力值 $A_i$，一个人最多参与两场比赛。一场比赛有两个人参加，并且这场比赛的等级差定义为两人能力值之差的绝对值。**如果第 $i$ 个人参加了两场比赛，那么两场比赛的对手的等级值必须是一个大于 $A_i$ 而另一个小于 $A_i$**。
    
    请你举办 $K$ 场比赛，使得每场比赛的等级差之和尽可能小。求出最小的等级差之和。$1 \le K \lt N \le 10^5$，$A_i$ 互不相同。

!!! warning "本题的一些细节"

    本题有一定的读题难度：一人最多参与两场比赛，并且参加的两场比赛还有具体的限制要求。此外，本题的数据范围也有一些提示信息：$K \lt N$，$A_i$ 互不相同。

对于第 $i$ 个人，他最多参加两场比赛，并且两场比赛的对手的等级值必须是一个大于 $A_i$ 而另一个小于 $A_i$，那么我们可以想到如下的贪心策略：

!!! 贪心策略1

    一开始就预先对每个人的等级值进行排序，由于 $A_i$ **互不相同**，那么在排序后离 $A_i$ 最近的数（一个比 $A_i$ 大，另一个比 $A_i$ 小）为 $A_{i - 1}$ 和 $A_{i + 1}$，这两场比赛的等级差为 $A_{i} - A_{i - 1}$ 和 $A_{i + 1} - A_{i}$。在这样的贪心策略下，最多可以举办 $N - 1$ 场比赛，等级差分别为 $A_2 - A_1, A_3 - A_2, \dots, A_N - A_{N - 1}$。这也刚好符合 $K \lt N$ 的要求。

举办 $K$ 场比赛，并且使得等级差之和最少，因此我们可以想到另一个贪心策略：

!!! 贪心策略2

    将贪心策略 1 中 $N - 1$ 场比赛的等级差的 $A_i - A_{i - 1}$ 进行排序，选出最小的 $K$ 个即可。

在代码上，两次 `sort` 排序便能解决问题。

??? 代码

    ```cpp
    #include <bits/stdc++.h>

    using namespace std;

    const int MAXN = 1e5 + 1;

    int n, k, a[MAXN], b[MAXN];

    int main() {
      ios::sync_with_stdio(0), cin.tie(0);
      cin >> n >> k;
      for (int i = 1; i <= n; i++) {
        cin >> a[i];
      }
      sort(a + 1, a + n + 1);
      for (int i = 1; i < n; i++) {  // 贪心策略 1：比赛对手一定是等级值 A_i 最接近的两人
        b[i] = a[i + 1] - a[i];
      }
      sort(b + 1, b + n);
      int ans = 0;
      for (int i = 1; i <= k; i++) {  // 贪心策略 2：优先选择等级差最小的比赛对手
        ans += b[i];
      }
      cout << ans;
      return 0;
    }
    ```

### 逐月 P1567 接水问题

!!! 题意

    有 $n$ 个人要接水，有 $m$ 个水龙头。给定 $n$ 个人的接水时长 $t_i$，按顺序让每个人接水，求所有人接完水的最小时间。

贪心策略：每次接水的人去的水龙头一定是最早接完水的水龙头。

正确性：从题意可知，当一个人接水完毕，排队的人会立马到他的位置接水。

??? 实现和时间复杂度

    我们用 $a_1, a_2, \dots, a_m$ 记录每个水龙头的接水量（由于一单位时间接一单位水，接水量完全等价于接水时长）。
    
    对于接下来要接水的第 $i$ 个人来说，他需要找到 $a_1 \sim a_m$ 中接水时长最小的水龙头，然后去接水。每次对 $a_1, a_2, \dots, a_m$ 排序，这样 $a_1$ 一定对应了最早接完水的水龙头，让第 $i$ 个人去该水龙头接水，然后更新接水时长 $a_1 \gets a_1 + t_i$ 即可。当 $n$ 个人都处理完后，最终答案就是 $a_i$ 的最大值。
    
    有 $n$ 个人要接水，每次需要排序找到接水时长最小的水龙头，时间复杂度 $O(n \times m \log m)$。

    更进一步，我们并不需要每次换人都重新排序，只需要通过暴力枚举找到哪个位置是最早接完水的就行了（即 $a_i$ 中最小值出现的位置）。时间复杂度降低为 $O(n \times m)$。

??? 代码

    ```cpp
    #include <bits/stdc++.h>

    using namespace std;

    const int N = 1e4 + 5;

    int a[N], n, m;

    int main() {
      cin >> n >> m;
      for (int i = 1; i <= n; ++i) {
        cin >> a[i];
      }
      for (int i = m + 1; i <= n; ++i) {
        // sort(a + 1, a + m + 1);
        int pos = 1, ans = a[1];
        for (int j = 1; j <= m; ++j) {
          if (a[j] < ans) {
            ans = a[j];
            pos = j;
          }
        }
        a[pos] += a[i];
      }
      sort(a + 1, a + 1 + m);
      cout << a[m] << '\n';
      return 0;
    }
    ```

## 习题

### 逐月 P1600 子序列判断

!!! 题意

    给你两个字符串 $S$ 和 $T$。请你判断 $T$ 是否为 $S$ 的子序列。

贪心策略：对于 $T$ 的每个字符，从 $S$ 中上一次与 $T$ 匹配的位置开始找到与当前查找字符相同的**最近位置**。

### 逐月 P1601 混合牛奶

!!! 题意

    给定 $m$ 个农民可以提供的牛奶量 $a_i$ 和一个单位牛奶量的售价 $p_i$，你可以一个单位一个单位的找农民购买牛奶，求出买到 $n$ 个单位牛奶量的最少价格。

贪心策略：优先找单位牛奶售价 $p_i$ 小的农民购买牛奶。

### 逐月 P1602 排队接水

!!! 题意

    有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。

贪心策略：优先让等待时间小的人接水。

如何理解这样的贪心策略？等待时间大的人排在前面，会让后面的人的等待时间都变多。

### 逐月 P1472 预定货物

!!! 题意

    有一个物品，这个物品在第 $i$ 天的进价和售价是 $a_i, b_i$，如果在第 $i$ 天购买，可以在第 $i + 1$ 天到第 $n$ 天中的任何一天进行出售。求买卖一次物品能够赚取到的最大差价是多少。

贪心策略 1：如果在第 $i$ 天出售，贪心地选择第 $1$ 天到第 $i - 1$ 天中进价最小的那天买。

??? 解题思路和时间复杂度分析

    枚举在第 $i$ 天出售，然后暴力循环查找前 $i - 1$ 天的最小进价，时间复杂度 $O(n)$，不能接受。

    观察到我们是求解一个【前缀】上的最小值，因此可以边枚举 $i$ 边更新前 $i - 1$ 天的最小值。时间复杂度 $O(n)$。

贪心策略 2：如果在第 $i$ 天购买，贪心地选择第 $i + 1$ 天到第 $n$ 天中售价最高的那天卖出。

### 逐月 P1598 纸币问题 II

本题用于说明，有时候思考得到的贪心策略不是正确的。

!!! 题意

    用若干张 $1, 3, 6, 10, 15$ 元的纸币凑出 $n$ 元。求所用纸币张数最小值。

纸币问题 I 的贪心策略在此题上是错误的。当 $n = 12$ 时：

- 使用该贪心策略，使用 $1$ 张 $10$ 元和 $2$ 张 $1$ 元纸币。
- 实际上的最优方式为，使用 $2$ 张 $6$ 元纸币。

这个题该如何解决，请进行思考。

??? 一种解法

    可以观察到面值为 $1, 3, 6, 10$ 的纸币的张数不会超过 $2, 1, 4, 2$ 张，因为：

    - $3$ 张 $1$ 元 = $1$ 张 $3$ 元
    - $2$ 张 $3$ 元 = $1$ 张 $6$ 元
    - $5$ 张 $6$ 元 = $2$ 张 $15$ 元
    - $3$ 张 $10$ 元 = $2$ 张 $15$ 元

    因此我们可以暴力枚举面值 $1, 3, 6, 10$ 的张数（一共 $3 \times 2 \times 5 \times 3 = 90$ 种情况），然后计算 $15$ 元纸币的数量，同时维护答案。
# 贪心

贪心算法（greedy algorithm），是模拟一个【贪婪的】人做决策的方式：每一步的选择和决定在当前时刻看来都是最优的。贪心算法只关心当前的选择是否是当前最优，而不考虑对未来的影响，并且一般也不会撤销以前做出的决定。这种【直接的】、【不犹豫的】做决定的方式，体现了贪心算法是一个非常高效率的算法。

## 一些性质和证明

设计贪心算法的难点在于设计一个正确的贪心策略，使得一定能够得到全局的最优解。

一般来说，一个正确的贪心算法需要满足两个性质：

- 最优子结构性质：一个问题的最优解包含子问题的最优解。
- 贪心选择性质：贪心策略只考虑已经做过的所有决策，不考虑未来情况，并且可以从不断的【局部的最优解】得到【全局的最优解】。

证明贪心算法的正确性，可以用到很多数学方法：反证法、数学归纳法、构造法等等。

## 如何在 J 组理解贪心

上面讲的都太学术了，很难理解。

在 J 组，可以将贪心算法理解成【设计一个贪心策略】并且【对贪心策略进行模拟】。由于现在的你证明贪心算法比较困难，不妨把贪心当做一种训练思维和第六感的工具:>

下面会给出一些经典的例子来帮助你理解【贪心策略】，而其中的正确性我们不会给出严谨的数学证明。

## 例题

### 逐月 P1597 纸币问题 I

!!! 题意

    用若干张 $1, 5, 10, 20, 50, 100$ 元的人民币纸币凑出 $n$ 元。求所用纸币张数最小值。

贪心策略：优先使用面值更大的人民币。

例如，为了凑出 $287$ 元，你需要使用 $2$ 张 $100$ 元、$1$ 张 $50$ 元、$1$ 张 $20$ 元、$1$ 张 $10$ 元、$1$ 张 $5$ 元、$2$ 张 $1$ 元纸币。在感觉上也能理解这样的策略所使用的的纸币张数一定最少。

将这样的贪心策略模拟实现即可。

??? 模拟步骤

    1. 首先计算出 $100$ 元的张数为 $[\frac{n}{100}]$，剩余钱数变为 $n \gets n \bmod 100$。
    2. 然后计算出 $50$ 元的张数为 $[\frac{n}{50}]$，剩余钱数变为 $n \gets n \bmod 50$。
    3. $\dots$

??? 代码

    ```cpp
    #include <bits/stdc++.h>

    using namespace std;

    const int a[] = {100, 50, 20, 10, 5, 1};

    int n, ans;

    int main() {
      cin >> n;
      for (int i = 0; i < 6; i++) {  // 贪心地优先使用大面值纸币凑钱
        ans += n / a[i];             // 计算纸币张数
        n %= a[i];                   // 计算剩余钱数
      }
      cout << ans;
      return 0;
    }
    ```

但这样地贪心策略一定是正确的吗？请见本笔记的最后一题。

### 逐月 P1599 数列分段

!!! 题意

    给你 $N$ 个正整数构成的序列，你要将其划分为若干个子段，每个元素都在恰好一个子段中，并且每个子段的数字和不超过 $M$。求最少分段数。

贪心策略：从前往后考虑每个数字，【尽量不分段】，这意味着如果数字能放进当前子段中就放，否则新建一个子段。

这样的策略也很好理解，尽量不分段，意思就是分段数量最少。

模拟实现即可。

??? 模拟步骤和时间复杂度
    
    定义变量 $sum$ 和 $cnt$ 记录当前子段和以及子段数量。

    对于 $i = 1, 2, \dots, N$ 的每个数字 $A_i$：
    
    - 如果当前数字能放进当前子段，即 $sum + A_i \le M$，那么直接放入，然后更新 $sum \gets sum + A_i$
    - 否则新开一个子段，更新 $cnt \gets cnt + 1, sum \gets A_i$

    时间复杂度 $O(N)$。

??? 代码

    ```cpp
    #include <bits/stdc++.h>

    using namespace std;

    const int MAXN = 1e5 + 1;

    int n, m, a[MAXN];

    int main() {
      ios::sync_with_stdio(0), cin.tie(0);
      cin >> n >> m;
      for (int i = 1; i <= n; i++) {
        cin >> a[i];
      }
      int cnt = 1, sum = 0;  // 已分段数，当前段的数字之和
      for (int i = 1; i <= n; i++) {
        if (sum + a[i] <= m) {  // 当前数字能放在当前段
          sum += a[i];          // 贪心地将当前数字放在当前段
        } else {
          sum = a[i], cnt++;  // 新开一段
        }
      }
      cout << cnt << '\n';
      return 0;
    }
    ```

### 逐月 P1275 超级书架

!!! 题意

    给定 $N$ 头奶牛的高度，选出尽可能少的奶牛，使得选出的奶牛的身高之和大于 $S$。

贪心策略：优先选择高度大的奶牛。

这种策略的正确性也非常的直观：一个高度大的奶牛可以代替多个高度低的奶牛。

学习完 `sort` 排序，相信你这道题一定能做出。

??? 步骤和时间复杂度

    将所有奶牛的高度进行 `sort` 排序
    
    按身高从高到低的顺序不断选出奶牛，直到身高之和大于 $S$。

    时间复杂度 $O(N \log N)$。

??? 代码

    ```cpp
    #include <algorithm>
    #include <iostream>

    using namespace std;

    const int MAXN = 2e5 + 1;

    int n, b, h[20010];

    bool cmp(int i, int j) {
      return i > j;
    }

    int main() {
      cin >> n >> b;
      for (int i = 1; i <= n; i++) {
        cin >> h[i];
      }
      sort(h + 1, h + n + 1, cmp);
      int sum = 0, ans = 0;
      for (int i = 1; i <= n; i++) {
        sum += h[i];
        if (sum >= b) {
          ans = i;
          break;
        }
      }
      cout << ans;
      return 0;
    }
    ```

### 逐月 P1603 象棋比赛

!!! 题意

    给定 $N$ 个人的能力值 $A_i$，一个人最多参与两场比赛。一场比赛有两个人参加，并且这场比赛的等级差定义为两人能力值之差的绝对值。**如果第 $i$ 个人参加了两场比赛，那么两场比赛的对手的等级值必须是一个大于 $A_i$ 而另一个小于 $A_i$**。
    
    请你举办 $K$ 场比赛，使得每场比赛的等级差之和尽可能小。求出最小的等级差之和。$1 \le K \lt N \le 10^5$，$A_i$ 互不相同。

!!! warning "本题的一些细节"

    本题有一定的读题难度：一人最多参与两场比赛，并且参加的两场比赛还有具体的限制要求。此外，本题的数据范围也有一些提示信息：$K \lt N$，$A_i$ 互不相同。

对于第 $i$ 个人，他最多参加两场比赛，并且两场比赛的对手的等级值必须是一个大于 $A_i$ 而另一个小于 $A_i$，那么我们可以想到如下的贪心策略：

!!! 贪心策略 1

    一开始就预先对每个人的等级值进行排序，由于 $A_i$ **互不相同**，那么在排序后离 $A_i$ 最近的数（一个比 $A_i$ 大，另一个比 $A_i$ 小）为 $A_{i - 1}$ 和 $A_{i + 1}$，这两场比赛的等级差为 $A_{i} - A_{i - 1}$ 和 $A_{i + 1} - A_{i}$。在这样的贪心策略下，最多可以举办 $N - 1$ 场比赛，等级差分别为 $A_2 - A_1, A_3 - A_2, \dots, A_N - A_{N - 1}$。这也刚好符合 $K \lt N$ 的要求。

举办 $K$ 场比赛，并且使得等级差之和最少，因此我们可以想到另一个贪心策略：

!!! 贪心策略 2

    将贪心策略 1 中 $N - 1$ 场比赛的等级差的 $A_i - A_{i - 1}$ 进行排序，选出最小的 $K$ 个即可。

在代码上，两次 `sort` 排序便能解决问题。

??? 代码

    ```cpp
    #include <bits/stdc++.h>

    using namespace std;

    const int MAXN = 1e5 + 1;

    int n, k, a[MAXN], b[MAXN];

    int main() {
      ios::sync_with_stdio(0), cin.tie(0);
      cin >> n >> k;
      for (int i = 1; i <= n; i++) {
        cin >> a[i];
      }
      sort(a + 1, a + n + 1);
      for (int i = 1; i < n; i++) {  // 贪心策略 1：比赛对手一定是等级值 A_i 最接近的两人
        b[i] = a[i + 1] - a[i];
      }
      sort(b + 1, b + n);
      int ans = 0;
      for (int i = 1; i <= k; i++) {  // 贪心策略 2：优先选择等级差最小的比赛对手
        ans += b[i];
      }
      cout << ans;
      return 0;
    }
    ```

### 逐月 P1567 接水问题

## 习题

### 逐月 P1600 子序列判断

### 逐月 P1601 混合牛奶

!!! 题意

    给定 $m$ 个农民可以提供的牛奶量 $a_i$ 和一个单位牛奶量的售价 $p_i$，你可以一个单位一个单位的找农民购买牛奶，求出买到 $n$ 个单位牛奶量的最少价格。

贪心策略：优先找单位牛奶售价 $p_i$ 小的农民购买牛奶。

### 逐月 P1602 排队接水

### 逐月 P1472 预定货物

### 逐月 P1598 纸币问题 II

本题用于说明，有时候思考得到的贪心策略不是正确的。

!!! 题意

    用若干张 $1, 3, 6, 10, 15$ 元的纸币凑出 $n$ 元。求所用纸币张数最小值。

纸币问题 I 的贪心策略在此题上是错误的。当 $n = 12$ 时：

- 使用该贪心策略，使用 $1$ 张 $10$ 元和 $2$ 张 $1$ 元纸币。
- 实际上的最优方式为，使用 $2$ 张 $6$ 元纸币。

这个题该如何解决，请进行思考。

??? 一种解法

    可以观察到面值为 $1, 3, 6, 10$ 的纸币的张数不会超过 $2, 1, 4, 2$ 张，因为：

    - $3$ 张 $1$ 元 = $1$ 张 $3$ 元
    - $2$ 张 $3$ 元 = $1$ 张 $6$ 元
    - $5$ 张 $6$ 元 = $2$ 张 $15$ 元
    - $3$ 张 $10$ 元 = $2$ 张 $15$ 元

    因此我们可以暴力枚举面值 $1, 3, 6, 10$ 的张数（一共 $3 \times 2 \times 5 \times 3 = 90$ 种情况），然后计算 $15$ 元纸币的数量，同时维护答案。
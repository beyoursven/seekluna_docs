# 最小生成树

minimum spanning tree，mst。不包括算法证明。

## 定义

生成子图：子图中的点集为原图中的点集。

生成树：无向连通图的生成子图，且该子图为树。也就是在原图中选择 $n - 1$ 条边和互相连通的 $n$ 个点构成的子图。类似地有生成森林的概念。

最小生成树：边权之和最小的生成树。不同于最短路，最小生成树仅要求图是简单图。

如果是非连通图，那就是生成森林。

对于非简单图，去掉自环，保留重边中最小边权的边，即可转换为简单图。

在生成树中和不在生成树中的边称为树边、非树边。

### 一些性质

图中任意一条非树边会和树边构成一个环，且非树边一定是所在环中的边权最大的边（反证）。

最小生成树不一定唯一。

## kruskal 算法

洛谷 P3366。

理解和实现最小生成树的最容易的算法。

从**边**的角度构造最小生成树

- 初始时有一个空图 $G$。

- 按边权从小到大的顺序处理每条边，如果当前边加入 $G$ 后不成环则加入到 $G$ 中，否则不加入。
- 如果加入了 $N - 1$​ 条边，说明最小生成树存在。

- 使用并查集判断是否成环（判断两个端点是否在同一连通块当中）。

对边排序 $O(M \log M)$，对于所有边使用并查集判断成环 $O(M + N \log N)$，总时间复杂度 $O(M \log M)$​​（边数比点数多）。

以下是洛谷 P3366 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXM = 2e5 + 1, MAXN = 5e3 + 1;

struct Edge {
  int u, v, w;
  bool operator<(const Edge &i) const {
    return w < i.w;
  }
} e[MAXM];

int n, m, ans, cnt, fa[MAXN];

int Find(int x) {
  return !fa[x] ? x : fa[x] = Find(fa[x]);
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> n >> m;
  for (int i = 1; i <= m; i++) {
    cin >> e[i].u >> e[i].v >> e[i].w;
  }
  sort(e + 1, e + m + 1);
  for (int i = 1; i <= m; i++) {
    int fu = Find(e[i].u), fv = Find(e[i].v);
    if (fu != fv) {
      fa[fu] = fv;
      ans += e[i].w, cnt++;
    }
  }
  if (cnt != n - 1) {
    cout << "orz";
  } else {
    cout << ans;
  }
  return 0;
}
```

kruskal 的本质在于【贪心+并查集判环】，而不是在于最小生成树的【最小】二字上（也就是说你求最大生成树也可以）。这点与最短路算法dijkstra不同，你显然不可能在一个正权边带环的图上去求最长路。

kruskal 算法，可以初始时看做每个点都是一个独立的连通块，每次成功加入一条边，说明连通块数量少 $1$。

## prim 算法

洛谷 P3366，P2872。

从**点**的角度构造最小生成树

- 随便选一个点放入生成树中。

- 不断选取离当前生成树距离最近的且不在生成树中的点加入树中。
  - 距离一般为最短距离的简称。
  - 点到生成树的距离，就是点到生成树中每个点的最短距离的最小值。
  - 这个距离会对应一条边，同时将点和边加入到树中。
- 每当新的点加入最小生成树，用它到其他点的边权来更新不在生成树中的其他点到最小生成树的距离。
  - 其他点到最小生成树的距离需要考虑多一个点，即当前新加入的点。
  - 不应该更新已在生成树中的点！！！！！

一共选取 $N$ 个点，每次寻找点和更新距离的时间复杂度为 $O(N)$，总时间复杂度 $O(N^2 + M) = O(N^2)$​（边数至多为点数平方级）。

```cpp
int Find() {
  int u = -1;
  for (int i = 1; i <= n; i++) {
    if (!vis[i] && (u == -1 || dis[i] < dis[u])) {
      u = i;
    }
  }
  return u;
}

void prim() {
  fill(dis + 1, dis + n + 1, INF);  // 初始化点到生成树的距离
  fill(vis + 1, vis + n + 1, 0);    // 初始化每个点都不在生成树中
  dis[1] = 0;
  for (int i = 1; i <= n; i++) {    // 往生成树中加入 n 个点
    int u = Find();                 // 寻找与生成树距离最近的点
    ans += dis[u], vis[u] = 1;      // 加入到生成树中
    for (int v = 1; v <= n; v++) {  // 更新其他点到生成树的距离
      if (!vis[v]) {
        dis[v] = min(dis[v], g[u][v]);
      }
    }
  }
}
```

算法和 dijkstra 类似：

- dijkstra 关心路径长度，而 prim 关心边的长度。
- prim 可以处理带负权边的图，而 dijkstra 不行。
- prim 的本质更讲究【贪心】，而 dijkstra 的本质更讲究【状态转移拓扑序】。

可以使用堆或优先队列优化，时间复杂度为 $O((N + M) \log N)$ 或 $O((N + M) \log M)$​。

```cpp

```

在（$N, M \le 10^5$）的图上应使用 kruskal，在（$N \le 10^3, M \le 10^5$）的图上应使用 prim（但实际上 kruskal 跑的也比 prim 快？）。

在稠密图上，暴力寻找距离最小的点比堆优 prim 的时间复杂度更低，前者 $O(N^2)$，后者 $O(M \log M)$。

prim 讲究去不断扩充生成树，而 kruskal讲究进行 n - 1 次的集合合并操作（也就是合并期间可能是个生成森林）。

## boruvka 算法

不讲。

## 应用

### MST

比较直观的 MST 题，应该考虑使用哪种最小生成树算法。

#### 洛谷 P2700

观察到用最少代价删边等价于用最多代价留边，因此尝试构建“最大生成树”。

#### 洛谷 P1550

这个题你显然可以用 kruskal 或者并查集的思路，尝试去构建最小生成树，但思考这样一个问题：所有点会连成一个连通块吗？

令虚拟点 $0$ 到每个点 $i$ 建立一条边权为 $W_i$ 的无向边，这样子可以方便的将点权转化为边权来实现。然后求包含 $0$​ 号点的 MST。

这道题也可以用 prim 做，并且完全不需要虚拟点的存在：

- 一开始每个点到生成树中的距离定义为 $W_i$。
- 相当于，你可以看做是有一个虚拟点到每个点的有向边。
  - 等价于，在有虚拟点时，先将 $0$ 号点放入 MST 中，然后做一轮更新操作。
  - 与 dijkstra 做多源最短路很像。


当然你可以用 kruskal + 不用虚拟点来实现，细节有点多。

#### 洛谷 P1195

翻译一下题目，是让你选一些边构成 $K$ 个连通块，最小化代价。可以发现每个联通快必然是个树。

直接上 kruskal，在加边时维护连通块数量（如何维护？）。

当然这题你也可以用 prim，但是有点麻烦：先要搜出原图有多少个连通块（用来判断第一种非法），然后对每个连通块各做一次 prim 构造生成森林（当然你也可以用类似于多源最短路的方式来一次性构造生成森林）。然后原图中的一个连通块还有不选一些边拆分为多个连通块……参考这篇题解 [wenxiang_MCL](https://www.luogu.com.cn/problem/solution/P1195)。

这种与连通块数量相关的题还是用 kruskal 方便。

#### CF 1245D

这个题还是有一定难度的，应该当考试题，这里当做习题了。

看数据范围猜到应该是用 prim。类似于洛谷 P1550，你可以一开始初始化每个点到生成树中的距离为 $c_i$，然后将两点之间边的长度修改为 $dist(u, v) \times (k_u + k_v)$ 即可。

可是不实际的建出虚拟点，我该咋知道哪些点建了电厂，建了哪些边呢？

- 在每次更新其他点到生成树的距离的时候，同时更新是哪个生成树上的点更新的。

### 瓶颈生成树和瓶颈路

#### 洛谷 P1396

瓶颈路。

你可以显然二分答案 $x$，将所有边权不超过 $x$ 的边加入图中，然后判断 $s, t$ 是否连通（单调性是什么？）。

实际上你可以参考【并查集 -> 贪心，生成树】的证明部分，贪心地按边权从小到大的顺序依次加入每条边到图中，直到 $s, t$​ 连通。你其实就是在构造最小生成树（或者其一部分）。

kruskal 和 prim 都可以，为了时间复杂度，保险起见用 kruskal。

#### 洛谷 P2330

瓶颈生成树。

与前一题没什么区别，不过数据范围支持你可以使用 prim 算法。

可能有重边。如何求答案？（prim 算法过程中，加入的两点之间的距离没有单调性）

#### 洛谷 P4047

这个题看上去和瓶颈生成树没什么关系，就是有个【最小值最大】的条件。当然可以使用二分答案来做。

##### kruskal

kruskal 算法，可以初始时看做每个点都是一个独立的连通块，每次成功加入一条边，说明连通块数量少 $1$。

使用 kruskal 算法构造生成树的过程中，令当前已经处理了所有 $\lt w$ 的点对并将边加入到生成树中，如果两点距离小于 $w$，此时一定在同一集合。随着 $w$ 的增大，连通块数量越来越少，连通块数量刚好达到 $k$​​ 时就是要求的答案。

##### prim

这个题可以用 prim 吗？？？

当然可以，构造瓶颈生成树，然后生成树上第 $K$ 大的边就是答案。

这也是我的实现。

## MST 的唯一性

对于一条非树边，如果它可以替换与其权值相同的、加入这条边后在环上的树边，则最小生成树不唯一。

在 kruskal 算法的过程中，对于权值相同的边，我们可以分别得到已加入图中、可能加入图中的边的数量，如果两种数量不一致，说明不唯一。

- 使用 kruskal 将所有 $\lt w$ 的边权处理好，然后对于所有权值为 $w$ 的边，只做边的两点是否在同一连通块中的判断，而不加边，求出了可能加入图中边的数量。然后再执行 kruskal 的算法流程，加入一些边权为 $w$ 的边。

## 次小生成树（严格次小和非严格次小）

以非严格次小生成树为例，有两种做法：

- 先 kruskal 构造一棵最小生成树 $T$。枚举去掉 $T$ 中的一条边，再进一步 kruskal 构造一棵最小生成树。时空复杂度 $O(NM \log M)$。
- 枚举一条非树边 $(u, v)$，然后去掉加入该边后环上的边权最大的树边。在生成树中找到 $u, v$​ 之间的最大边，将在在 LCA、倍增章节之后讲解。

洛谷 P4180

[链接](https://oi-wiki.org/graph/mst)

## 题目

洛谷 P3366：kruskal 模板

洛谷 P2872：prim 模板

洛谷 P2700，洛谷 P1550，洛谷 P1195，CF 1245D：没有什么价值的模板题

POJ 1679，CF 1108F：最小生成树唯一性

洛谷 P2330，洛谷 P4047，洛谷 P1396：瓶颈生成树

POJ 2728：最优比率生成树
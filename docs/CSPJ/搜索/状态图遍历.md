# 状态图遍历（flood fill，洪水填充）

一句话：每个状态只需遍历一次。无需回溯。

- 搜索带回溯，相当于是用搜索实现了暴力枚举。带回溯的搜索通常处理的是**枚举所有方案**的问题。
- 状态图遍历，相当于每个状态都只遍历一次，而不关心具体搜到该状态的搜索路径。状态图遍历通常只想知道**每个状态是否可以转移得到**。

```cpp
void dfs(当前状态 x) {  // 不一定需要通过参数来获取状态信息
  if (x 非法，或走到边界，或当前状态 x 已遍历过) {
    return;
  }
  标记当前状态 x 已遍历;
  for (x 转移出的每个新状态 y) {
    dfs(新状态 y);
  }
}
```

```cpp
void dfs(当前状态 x) {  // 不一定需要通过参数来获取状态信息
  标记当前状态 x 已遍历;
  for (x 转移出的每个新状态 y) {
    if (x 非法，或走到边界，或当前状态 x 已遍历过) {
      continue;
    }
    dfs(新状态 y);
    /*
    if (状态合法) {
    	dfs(新状态 y);
    }
    */
  }
}
```

状态图遍历的时间复杂度通常由总状态数和总转移数构成，也就是说如果有 $N$ 个状态，总共有 $M$ 个转移，那么时间复杂度是 $O(N + M)$。

一定要写状态、转移、时空复杂度。

## lake counting

网格图，某些格子有水，有水的格子可以与八连通的有水的格子连成一个水洼，求出水洼个数。

连通块：无向图中的概念，连通块内的所有结点（状态）互相连通，连通块之间的结点（状态）不连通。

### 思路

以一个没有遍历过的有水的格子为起点进行搜索，遍历所有与之相连的有水的格子形成一个水洼。这样每个格子最多被搜索遍历一次。

状态是格子坐标 $(x, y)$，转移是八连通方向，转移到 $(x + dx[i], y + dy[i])$。

这样的搜索被称为寻找**连通块**。

```cpp
#include <iostream>

using namespace std;

const int N = 101;
const int dx[] = {0, 0, 1, -1, -1, -1, 1, 1};
const int dy[] = {1, -1, 0, 0, -1, 1, -1, 1};

char a[N][N];
bool vis[N][N];  // 记录每个状态是否被遍历过
int cnt, n, m;   // cnt 记录能走到的格子的数量

void dfs(int x, int y) {
  if (x < 1 || y < 1 || x > n || y > m || a[x][y] == '.' || vis[x][y]) {  // 合法性判断、遍历判断
    return;
  }
  vis[x][y] = 1;   // 标记遍历过状态
  for (int i = 0; i < 8; i++) {
    dfs(x + dx[i], y + dy[i]);
  }
}

int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      cin >> a[i][j];
    }
  }
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      if (a[i][j] == 'W' && !vis[i][j]) {  // 寻找一个有水的未遍历过的格子
        cnt++;                             // 更新连通块数量
        dfs(i, j);                         // 以该格子为起点进行搜索
      }
    }
  }
  cout << cnt << endl;
  return 0;
}
```

空间复杂度：记录迷宫，$O(n \times m)$，递归层数最多 $O(n \times m)$。

时间复杂度：

- 每个状态被遍历一次，$O(n \times m)$。
- 每个状态转移 $8$ 次，总转移次数为 $8 \times n \times m$。
- 总时间复杂度 $O(n \times m)$ **（状态数 + 转移数）**。

## 奇怪的电梯

有 $n$ 层楼和一个电梯，第 $i$ 层有按钮和一个数字 $x_i$，表示电梯可以往上或往下走 $x_i$ 层，求 $a$ 层到 $b$ 层按按钮的最少次数。

### 思路

状态：$(x, cnt)$ 表示当前在第 $x$ 层楼，按了 $cnt$ 次按钮。

转移：$(x, cnt) \rightarrow (x \pm K_x, cnt + 1)$，要保证转移到合法楼层（$1 \sim n$），还需要保证最多按 $n$ 次按钮（鸽巢原理）。

先通过 flood fill 遍历所有状态，再求出题目所要求的的答案。

```cpp
#include <iostream>

using namespace std;

const int N = 201;

int num[N], n, a, b;
bool vis[N][N];  // 记录状态是否遍历

void dfs(int x, int step){
  if (x <= 0 || x > n || step > n || vis[x][step]){  // 合法性判断，遍历判断
    return ;
  }
  vis[x][step] = 1;           // 记录状态
  dfs(x + num[x], step + 1);  // 转移
  dfs(x - num[x], step + 1);
}

int main(){
  cin >> n >> a >> b;
  for (int i = 1; i <= n; i++){
    cin >> num[i];
  }
  dfs(a, 0);                     // 从初始状态出发做搜索
  for (int i = 0; i <= n; i++){  // 求最少按按钮次数
    if (vis[b][i]){              // 状态被遍历过
      cout << i;
      return 0;
    }
  }
  cout << -1;
  return 0;
}
```

空间复杂度：状态空间 $O(n^2)$。

时间复杂度：每个状态被遍历一次 $O(n^2)$，每个状态转移 $2$ 次 $O(n^2)$，总时间复杂度 $O(n^2)$。

## 母亲的牛奶

记三个桶为 $A, B, C$。

状态：$(x, y, z)$ 表示三个桶中的牛奶量为 $x, y, z$ 升。

转移：

- $A$ 桶倒 $B$ 桶，$(x, y, z) \rightarrow (x - \min(x, b - y), y + \min(x, b - y), z)$
- $B$ 桶倒 $A$ 桶，$(x, y, z) \rightarrow (x + \min(y, a - x), y - \min(y, a - x), z)$
- $A$ 桶倒 $C$ 桶，自己推
- $C$ 桶倒 $A$ 桶，自己推
- $B$ 桶倒 $C$ 桶，自己推
- $C$ 桶倒 $B$ 桶，自己推

令三个桶的容量为 $v$。

空间复杂度 $O(v^3)$。

先做完状态图遍历，然后找 $A$ 桶为空（$x = 0$）时 $C$ 桶中牛奶量的可能性。

标记状态 $O(v^3)$，每个状态 $6$ 个转移 $O(v^3)$，总时间 $O(v^3)$。

## 观星

找连通块类型的题目。注意题目对星座和星系的定义，星座是连通块，星系是同样大小的连通块构成的集合。

令最大星系大小为 $v$。

空间复杂度：状态标记 $O(nm)$，记录星系 $O(v)$，总空间 $O(nm + v)$。

时间复杂度：状态图遍历求星系和星座 $O(nm)$，枚举求解星系数量和最大星系 $O(v)$，总时间 $O(nm + v)$。

## 01 迷宫

本题有一个迷惑点：你当前所处的格子和你接下来走到的格子数字不同。看上去行走过程中数字不同，但本质上还是构成了一个连通块。

### 60 分

对于每次询问，做一次从给定起点 $(i, j)$ 的状态图遍历，时间 $O(m \times n^2)$。

### 100 分

先对整个网格图做一遍状态图遍历，记录每个格子所属的连通块，接下来只用记录连通块中包含多少个格子就好了。时间复杂度 $O(m + n^2)$。

## 求细胞数量

裸的连通块搜索。

## 填涂颜色

状态图遍历，可以先将外圈的 $0$ 通过搜索标记一遍，剩下未标记的 $0$ 就是需要填充颜色的部分。

如何找外圈的 $0$，枚举四条边界上的所有 $0$，做状态图遍历。时间复杂度 $O(n^2)$。


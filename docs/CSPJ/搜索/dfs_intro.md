# 搜索和 dfs 介绍

深度优先搜索（DFS, depth-first search）

状态：解决问题所关注的属性的集合。（语文成绩，数学成绩，英语成绩）

转移：状态之间的变化过程。(50, 50, 50) $\rightarrow$ (100, 100, 100)

搜索：处理状态转移、寻找新状态、枚举（遍历）所有状态的一种算法思想。本质仍然是枚举。

搜索树（状态转移图）：状态和有效转移形成的**树形结构**，每个状态只会被**扩展一次**。

## 引入

全称为 depth-first search，简称 dfs、深搜。

状态：当前所处的格子。

转移：向下走和向右走

![](https://cdn.luogu.com.cn/upload/image_hosting/8s92i850.png)

### 伪代码

一个模板化的 dfs 伪代码如下：

```cpp
void dfs(当前状态 x) {  // 不一定需要通过参数来获取状态信息
  if (x 为非法状态) {
    return;
  }
  for (x 转移出的每个新状态 y) {
    dfs(新状态 y);
  }
}
```

具体代码应根据题目和自身理解来确定。

### 特性

- 处理转移，得到新状态后，**立即**对新状态处理，新状态处理完后，**再**处理旧状态。也就是，新状态处理的优先级最高。

- 需要记录旧状态处理进度，不应该重复转移。

    - 用**递归函数的调用**处理新状态，调用时会将旧状态的处理进度**保存在栈内存中**。
    - 新状态处理完后，程序回到调用函数入口。

- 新状态回到旧状态的过程称为**回溯**（backtracking）。
    - 相当于，递归调用是把旧状态处理进度压入栈顶，递归结束后弹出栈顶回到旧状态。

- 搜索树中，任意一棵子树中的所有状态，均是被连续扩展出来的。（可以不讲）
    - 状态扩展的顺序通常称为 **dfs 序**。

深搜本质上是一种**枚举遍历所有状态**的算法。

### 写题要求

写搜索时注释状态、转移（写到具体的转移部分）、时间复杂度（网格图不用写）。
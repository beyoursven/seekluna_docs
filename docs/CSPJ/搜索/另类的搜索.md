# 另类的搜索

用循环的方式实现搜索枚举

## 排列

`next_permutation`，`prev_permutation`。

C++ 预先将排列算法封装为函数 `next_permutation`，并放入头文件 `<algorithm>`。类似于 `sort`，用法为 `next_permutation(首地址，尾地址)`。

例如 `next_permutation(a + 1, a + n + 1)` 使得 $a$ 数组所存储的排列变为**字典序更大的下一个排列**，当不存在更大的全排列时，函数返回 `false`。下方代码生成了所有全排列。

```cpp
for (int i = 1; i <= n; i++) {
  a[i] = i;
}
do {
  print(a);  // 输出全排列
  Check(a);  // 对全排列做一些事情
} while (next_permutation(a + 1, a + n + 1));
```

`prev_permutation` 使得 $a$ 数组所存储的排列变为**字典序更小的上一个排列**，当不存在更小的全排列时，函数返回 `false`。

时间复杂度均摊是 $O(1)$，生成所有全排列时间复杂度为 $O(n!)$。

注意：

- 如果需要生成所有全排列，在使用 `next_permutation` 之前需要先将 $a$ 数组排序。
- `next_permutation` 对于可重集排列也是有效的，例如对序列 `1 2 2` 调用一次该函数可以得到序列 `2 1 2`。

## 组合

状态压缩表示，简称为状压，通常情况下是一种用二进制来实现枚举的技巧。

例如在本题中 $n = 5$ 的情况下，二进制的状态压缩表示 $(10110)_2$ 表示选取了 $2, 3, 5$ 这三个数字，参见下标。

| 位号     | 4   | 3   | 2   | 1   | 0   |
| -------- | --- | --- | --- | --- | --- |
| 代表数字 | 5   | 4   | 3   | 2   | 1   |
| 压缩表示 | 1   | 0   | 1   | 1   | 0   |

枚举 $n$ 个元素的所有挑选元素的方案（共 $2^n$ 种），对于每一种方案检查其是否挑选了 $m$ 个元素。

```cpp
for (int i = 0; i < (1 << n); i++) {  // n 位二进制，枚举 2^n 种选取方案
  int c = 0;                          // 统计压缩表示中 1 的数量，即挑选数字的个数
  for (int j = 0; j < n; j++) {       // 枚举压缩表示的每一位
    c += i >> j  & 1;                  // 统计数量
  }
  if (c == m) {  // 找到一个组合
    Check(i);    // 对组合做一些事情
  }
}
```
    
空间复杂度 $O(1)$。
    
时间复杂度：

- 枚举压缩表示，$O(2^n)$。
- 判断一个组合，$O(n)$。
- 总时间复杂度 $O(n \times 2^n)$。

## 子集

### 状压枚举

枚举 $n$ 个元素的所有挑选元素的方案（共 $2^n$ 种）。

```cpp
for (int i = 0; i < (1 << n); i++) {  // n 位二进制，枚举 2^n 种选取方案
  for (int j = 0; j < n; j++) {       // 枚举压缩表示的每一位
  	if (i >> j & 1) {                 // 输出子集
      cout << j << ' ';
    }
  }
  cout << '\n';
}
```

空间复杂度 $O(1)$。

时间复杂度:

- 枚举压缩表示，$O(2^n)$。
- 输出子集，$O(n)$。
- 总时间复杂度 $O(n \times 2^n)$。
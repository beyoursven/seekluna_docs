# 二分查找

二分（Binary Search）是在**有序数列**上优化查找指定值的元素的一种算法。

学习要求：

- 二分查找 I II III 记笔记
- `lower_bound()` 和 `upper_bound()` 的使用记笔记。
- `lower_bound()` 和 `upper_bound()` 的转化需要在课堂上写出。

## 二分查找学习

### 二分查找

!!! note "逐月 P1443 整数查找"

    给定一个长度为 $N$ 的**单调递增**序列 $a_1 \lt a_2 \lt \dots \lt a_N$，$Q$ 次询问，每次询问给出 $x$，请你找到 $x$ 出现的位置，如果没出现，输出 `-1`。$N, Q \le 10^5$。
    
我们先不考虑所有基于值索引的算法（也就是 `map`）。

如果从前往后暴力枚举查找，单次时间复杂度为 $O(N)$，总时间复杂度为 $O(QN)$，超时。

注意到序列中元素是**单调递增**的。对于题目中给出的一个整数 $x$，我们可以将序列依次分为：$\lt x$、$= x$、$\gt x$ 的三个部分。

类似于猜数字游戏，二分查找每次考察数组当前部分的中间元素：

- 如果中间元素刚好是要找的，就结束查找过程；
- 如果中间元素小于所查找的值，那么左侧的元素只会更小，不会有查找的元素，只需到右侧查找；
- 如果中间元素大于所查找的值，那么右侧的元素只会更大，不会有查找的元素，只需到左侧查找。

接下来给出在升序序列中进行二分查找的算法步骤：

- 令当前我们要查找的区间为 $[l, r]$。初始时，$l = 1, r = N$。
- 不断执行以下步骤，直到 $l \gt r$
    - 取出**区间的中点** $mid = \lfloor \dfrac{l + r}{2} \rfloor$
    - 如果 $a_{mid} = x$，恭喜你找到了答案，退出二分查找流程。
    - 如果 $a_{mid} \lt x$，说明 $x$ 不会在中点左边，将查找区间调整为 $[mid + 1, r]$。 
    - 如果 $a_{mid} \gt x$，说明 $x$ 不会在中点右边，将查找区间调整为 $[l, mid - 1]$。

由于每次调整区间时，区间的大小会减半，因此单次二分查找的时间复杂度为 $O(\log N)$，本题的总时间复杂度为 $O(N + Q \log N)$。

例如，对于数组 $a = [3, 5, 8, 13, 18, 19, 21, 27, 32]$ 以及某次询问给出的 $x = 13$，请学生给出每次二分查找的区间范围。

!!! 代码

    ```cpp
    int l = 1, r = n;  // 初始化二分查找的范围
    while (l <= r) {   // 循环结束时一定有 l == r + 1
      int mid = (l + r) / 2;
      if (a[mid] == x) {  // 找到答案
        break;
      } else if (a[mid] < x) {  
        l = mid + 1;  // 答案只可能在右边
      } else {                  
        r = mid - 1;  // 答案只可能在左边         
      }
    }
    ```

在一般情况下，我们更习惯于将**单调序列**分成两段来处理。具体处理过程请见下面两题。

除非特殊强调，默认序列均为单调递增序列。

### 查找大于等于 $x$ 的最小位置

!!! note "逐月 P1605 二分查找 I"

    给定长度为 $N$ 的**单调不减**序列 $a_1 \le a_2 \le \dots \le a_N$，有 $Q$ 次询问，每次询问给出一个整数 $x$，查找序列中大于等于 $x$ 的最小位置，如果不存在 $x$，输出 $N + 1$。$N, Q \le 10^5$。

本题中，我们要求解的答案有以下几种描述方法：

1. 查找序列中大于等于 $x$ 的**第一个**位置
2. 查找满足 $a_i \ge x$ 的**最小**的 $i$（$1 \le i \le N$）

例如，当 $a = [-12, -6, -4, 3, 5, 5, 8, 9]$ 时，令 $p$ 为所求答案：

* $x = -5$ 时，$p = 3$；
* $x = 7$ 时，$p = 7$；
* $x = 5$ 时，$p = 5$；
* $x = 10$ 时，$p = 9$，可以视为该位置超出了区间，即越界（或非法）。

我们不再将序列分为三段，而是将序列分为两段：前面一段都是 $\lt x$ 的元素，后面一段都是 $\ge x$ 的元素。

由于序列分成两段，在之前二分查找算法中，调整区间的判断条件和记录答案的方法需要稍加改变：

- 如果 $a_{mid} \ge x$，则 $mid$ 有可能是答案，将其记录下来，然后调整查找区间为 $[l, mid - 1]$。
- 否则，答案不可能在左半区间中，调整查找区间为 $[mid + 1, r]$。

判断条件 $a_{mid} \ge x$ 第一次成立时，并不意味着已经求出答案。例如，当 $a = [1, 1, 1, 2, 2, 2, 3, 3, 3]$，$x = 1$ 时，第一次二分查找的位置为 $5$，而其并不是序列中大于等于 $1$ 的最小位置，我们还需要继续查找下去。

!!! 代码

    ```cpp
    int BinarySearch(int x) {
      int l = 1, r = n;  // 初始化查找区间范围
      int ans = n + 1;   // 初始化答案，用于记录无解情况
      while (l <= r) {
        int mid = (l + r) / 2;
        if (a[mid] >= x) {
          ans = mid;    // 当前位置可能为答案，记录答案
          r = mid - 1;  // 调整区间
        } else {
          l = mid + 1;  // 调整区间
        }
      }
      return ans;
    }
    ```

单次查找的时间复杂度为 $O(\log N)$，总时间复杂度为 $O(N + Q \log N)$。

### 查找小于等于 $x$ 的最大位置

!!! note "逐月 P1606 二分查找 II"

    给定长度为 $N$ 的**单调不减**序列 $a_1 \le a_2 \le \dots \le a_N$，有 $Q$ 次询问，每次询问给出一个整数 $x$，查找序列中小于等于 $x$ 的最大位置，如果不存在 $x$，输出 $0$。$N, Q \le 10^5$。

本题中，我们要求解的答案有以下几种描述方法：

1. 查找序列中小于等于 $x$ 的**最后一个**位置
2. 查找满足 $a_i \le x$ 的**最大**的 $i$（$1 \le i \le N$）

类似地，我们将序列分为两段：前面一段都是 $\le x$ 的元素，后面一段都是 $\gt x$ 的元素。在二分查找过程中：

- 如果 $a_{mid} \le x$，则 $mid$ 有可能是答案，将其记录下来，然后调整查找区间为 $[mid + 1, r]$。
- 否则，答案不可能在右半区间中，调整查找区间为 $[l, mid - 1]$。

!!! 代码

    ```cpp
    int BinarySearch(int x) {
      int l = 1, r = n;  // 初始化查找区间范围
      int ans = 0;       // 初始化答案，用于记录无解情况
      while (l <= r) {
        int mid = (l + r) / 2;
        if (a[mid] <= x) {
          ans = mid;    // 当前位置可能为答案，记录答案
          l = mid + 1;  // 调整区间
        } else {
          r = mid - 1;  // 调整区间
        }
      }
      return ans;
    }
    ```

单次查找的时间复杂度为 $O(\log N)$，总时间复杂度为 $O(N + Q \log N)$。

### 查找指定值域内的整数数量

!!! note "逐月 P1607 二分查找 III"

    给定 $N$ 个元素 $a_1, a_2, \dots a_N$，有 $Q$ 次询问，每次询问给出一对整数 $(l, r)$，请你求出有多少个元素的取值 $a_i$ 在 $[l, r]$ 之间。$N, Q \le 10^5$。

注意，题目中的元素是乱序的，在使用二分查找之前，应该先将其排序。令排序后的元素为 $b_1, b_2, \dots, b_N$。

对于每次询问给出的 $(l, r)$，我们可以找到 $b$ 序列中大于等于 $l$ 的最小位置 $x$，以及小于等于 $r$ 的最大位置 $y$，那么 $b_x, b_{x + 1}, \dots, b_{y}$ 都是符合要求的元素，$y - x + 1$ 为所求答案。

- 注意到，如果不存在符合要求的元素，二分查找求出的 $x$ 和 $y$ 恰好满足 $x - 1 = y$，因此答案为 $0$。

单次询问的时间复杂度为 $O(\log N)$，总时间复杂度为 $O(N + Q \log N)$。

## STL 函数 lower_bound 与 upper_bound()

### 引入

给定一个有序数组，令 `lb(x)` 返回 $\ge x$ 的第一个位置，`ub(x)` 返回 $\gt x$ 的第一个位置：

- 求解 $\ge x$ 的第一个位置，`lb(x)`，`ub(x - 1)`
- 求解 $\gt x$ 的第一个位置，`lb(x + 1)`，`ub(x)`
- 求解 $\le x$ 的最后一个位置，`lb(x + 1) - 1`，`ub(x) - 1`
- 求解 $\lt x$ 的最后一个位置，`lb(x) - 1`，`ub(x - 1) - 1`
- 找到第一个 $= x$ 的位置，`a[lb(x)] == x`，`a[ub(x - 1)] == x`
- 找到最后一个 $= x$ 的位置，`a[lb(x + 1) - 1] == x`，`a[ub(x) - 1] == x`

（给出第一个例子，后面例子要求学生写出 `lb` 和 `ub` 的版本）

### lower_bound() 与 upper_bound()

如果题目只是需要简单的二分查找，可以利用 C++ STL 中自带的二分函数 `lower_bound` 和 `upper_bound`。使用函数的前提是保证查找的区间是单调不减的。函数所在的头文件为 `<algorithm>`。

单次调用 `lower_bound()` 和 `upper_bound()` 函数的时间复杂度为 $O(\log n)$，其中 $n$ 为查找范围的大小。

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main () {
  int a[] = {10, 20, 30, 30, 20, 10, 10, 20};

  // sort(a, a + 8);
  // &：获取数据所处的内存地址
  // *：获取内存地址存储的数据

  sort(&a[0], &a[8]);  // 10 10 10 20 20 20 30 30

  // lower_bound(首地址，尾地址，元素 x)，返回 [首地址, 尾地址) 中第一个大于等于 x 的元素的地址
  // upper_bound(首地址，尾地址，元素 x)，返回 [首地址, 尾地址) 中第一个大于 x 的元素的地址
  // 如果在范围内查找不到元素，返回尾地址
  // 在数组上，两个元素之间的地址相减，可以得到它们的下标之间间隔的距离
  // 可以通过 lower_bound(a + l, a + r, x) - a 获得 a[l] ~ a[r - 1] 中第一个大于等于 x 的元素的下标
  // 可以通过 upper_bound(a + l, a + r, x) - a 获得 a[l] ~ a[r - 1] 中第一个大于 x 的元素的下标

  int l = lower_bound(a, a + 8, 20) - a;  // 3，a[3] 是第一个大于等于 20 的元素的地址
  int r = upper_bound(a, a + 8, 20) - a;  // 6，a[6] 是第一个大于 20 的元素的地址
  cout << *upper_bound(a, a + 8, 20);     // 30

  // lower_bound(迭代器 a, 迭代器 b, 元素 x)，返回 [迭代器 a, 迭代器 b) 中第一个大于等于 x 的迭代器，仅允许在 vector 上使用
  // upper_bound(迭代器 a, 迭代器 b, 元素 x)，返回 [迭代器 a, 迭代器 b) 中第一个大于 x 的迭代器，仅允许在 vector 上使用
  // 如果在范围内查找不到元素，返回迭代器 b
  // 在 vector 上，两个元素对应的迭代器相减，可以得到它们的下标之间间隔距离

  vector<int> v(a, a + 8);  // 10 10 10 20 20 20 30 30

  sort (v.begin(), v.end());  // 10 10 10 20 20 20 30 30

  int low = lower_bound(v.begin(), v.end(), 20) - v.begin();  // 查找大于等于 x 的最小位置，low = 3
  int upp = upper_bound(v.begin(), v.end(), 20) - v.begin();  // 查找大于 x 的最小位置，upp = 6

  std::cout << "lower_bound at position " << low << '\n';  // 输出 3
  std::cout << "upper_bound at position " << upp << '\n';  // 输出 6
  
  int n;
  int pos1 = lower_bound(a + 1, a + n + 1, x) - a;
  if (pos1 == n + 1) {  // 判定 a[1] ~ a[n] 中不存在大于等于 x 的元素
    
  }

  return 0;
}
```

### 题目

洛谷 P1444 P2249 P1571 P1102 P1678 P3184 P8889
# 栈

![](https://oi-wiki.org/ds/images/stack.svg)

栈是一种先进后出（first in last out，FILO）的线性结构。

栈的两端被称为栈底和栈顶，只能在栈顶压入或弹出元素。

可以用单链表实现栈，栈顶就是链表头，栈底就是链表尾。

## STL stack

C++ STL 提供了一个栈容器 `stack`。

```cpp
#include <stack>  // 引入头文件

stack<Type> s;  // Type 为数据类型，定义了一个存储 Type 元素的栈，一开始为空

s.push(item);     // 把元素 item 压入栈顶
cout << s.top();  // 访问栈顶元素
s.pop();          // 弹出栈顶元素
s.size();         // 返回栈中元素数量
s.empty();        // 返回栈是否为空，栈空返回 true，否则返回 false
```

上述成员函数时间复杂度均为 $O(1)$。

在进行 `.pop()`、`.top()` 操作时，注意容器不能为空。

实际上，`stack` 可以被 `vector` 替代。

注意，`stack` 没有 `.clear(), .begin(), .end()` 成员函数。

题目：洛谷 B3614 STL 栈

## 数组模拟栈

```cpp
int a[100];     // 数组模拟栈
int t = 0;      // 栈顶指针，栈底元素从 1 开始编号，也可以用来表示栈的大小
bool empty() {  // 判断栈空
  return !t;
}
void push(int x) {  // 压入元素
  a[++t] = x;
}
void pop(int x) {  // 弹出元素
  if (!empty()) {  // 注意，弹出栈顶元素时栈不能为空
    t--;
  }
}
int top() {        // 取出栈顶元素
  if (!empty()) {  // 注意，取出栈顶元素时栈不能为空
    return a[t];
  }
}
void clear() {     // 清空栈
  t = 0;
}
void print() {  // 遍历栈
  for (int i = top; i > 0; i--) {
    cout << a[i] << ' ';
  }
}
```

相比 STL `stack`，数组模拟栈可以实现的操作更多（因为支持下标访问）。

题目：逐月 P1336 数组模拟栈

## 应用

### 括号序列

!!! 题目

    给定一个由 `(` 和 `)` 组成的字符串，判断该字符串是否为合法的括号序列。合法括号序列定义如下：

    1. 字符串 $s$ 为空时，$s$ 为合法括号序列；
    2. 如果 $s$ 是合法的括号序列，则 `(s)` 也是合法的括号序列；
    3. 如果 $s$ 和 $t$ 是合法的括号序列，则 $st$ 也是合法的括号序列。

合法的括号序列有如下两种判定方法（同时也是等价的定义）：

!!! 判定

    === "栈"

        ```markdown
        - 从前往后扫描括号序列。
          - 碰到左括号入栈
          - 碰到右括号时，如果栈为空，说明括号序列不合法，否则弹出栈顶。
        - 如果栈不为空，则括号序列不合法。

        上述构造方法，实质是对每个右括号去配对了左边的最近的未配对的左括号。
        ```

    === "前缀和"

        ```markdown
        令 $sum_i$ 表示前 $i$ 个括号中未匹配的左括号。

        - 从前往后扫描括号序列
          - 如果 $s_i = $ `(`，$sum_i = sum_{i - 1} + 1$；
          - 否则 $s_i = $ `)`，$sum_{i} = sum_{i - 1} - 1$。

        则一个合法括号序列满足，对于任意 $1 \le i \le n$ 都有 $sum_i \ge 0$（任意时刻左括号数量都比右括号数量多），并且 $sum_n = 0$。

        $sum_i$ 可以看做是待匹配的做括号数量、栈的大小。`(` 和 `1` 相当于是入栈，`)` 和 `-1` 相当于是出栈。
        ```

### 单调栈

逐月 P1339 单调栈

!!! 题意

    给定整数序列 $a_1, a_2, \dots, a_n$，定义函数 $f(i)$ 代表数列中第 $i$ 个元素之后第一个大于 $a_i$ 的元素的**下标**，即 $f(i)=\min \limits_{i<j\leq n, a_j > a_i} \{j\}$。若不存在，则 $f(i)=0$。试求出 $f(1) \dots f(n)$。

如果我们对于每个元素 $a_i$ 都向右查找第一个比它大的元素，效率肯定不高，时间复杂度最坏 $O(n)$。

不妨换个观察角度，我们考虑对每个元素 $a_i$ 往左边查找，看它左边有哪些未确定答案的元素的答案是当前位置 $i$。

由于我们是往左边查找，那么最先观察的元素是 $a_i$ 左边离它最近的未确定答案的元素，我们可以使用栈来维护这些元素，栈顶元素就是左边离它最近的元素。

从左到右扫描序列，对于每个元素，只要当前元素比栈顶元素大，就可以记录答案，直到栈为空或者当前元素小于等于栈顶元素。

例如，对于序列 $[5, 2, 1, 3, 4, 4]$：

1. 处理 $a_1 = 5$，栈为空，将 $5$ 入栈，得到 $[5]$。
2. 处理 $a_2 = 2$，$2$ 小于 $5$，将 $2$ 入栈，得到 $[5, 2]$。
3. 处理 $a_3 = 1$，$1$ 小于 $2$，将 $1$ 入栈，得到 $[5, 2, 1]$。
4. 处理 $a_4 = 3$
   1. $3$ 大于 $1$，记录 $f(3) = 4$，弹出栈顶元素，得到 $[5, 2]$。
   2. $3$ 大于 $2$，记录 $f(2) = 4$，弹出栈顶元素，得到 $[5]$。
   3. $3$ 小于 $5$，将 $3$ 入栈，得到 $[5, 3]$。
5. 处理 $a_5 = 4$，
   1. $4$ 大于 $3$，记录 $f(4) = 5$，弹出栈顶元素，得到 $[5]$。
   2. $4$ 小于 $5$，将 $4$ 入栈，得到 $[5, 4]$。
6. 处理 $a_6 = 4$，$4$ 等于 $4$，将 $4$ 入栈，得到 $[5, 4, 4]$。
7. 结束时，$a_1, a_5, a_6$ 的答案 $f(1) = f(5) = f(6) = 0$。

我们可以观察到，栈中的元素始终是单调不增的，因此该方法被称为单调栈。

### 后缀表达式

洛谷 P1449 后缀表达式

给定一个后缀表达式，计算后缀表达式的值。计算规则如下：

1. 如果是操作数，则压入栈中；
2. 如果是操作符，弹出栈顶两个操作数。令先后弹出栈的元素为 $x, y$，计算结果 $y op x$，并将结果压入栈中。（$x$ 和 $y$ 的运算顺序将在二叉树章节提到）







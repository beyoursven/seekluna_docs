# 位运算

逻辑运算符：`&&, ||, !`

位运算符：`&, |, ^, ~, >>, <<`

位运算的符合运算符：`&=, |=, ^=, ~=, >>=, <<=`

## 与，或，异或，非

### 真值表

- 位与运算真值表

| &, and | $0$ | $1$ |
| ------ | --- | --- |
| $0$    | $0$ | $0$ |
| $1$    | $0$ | $1$ |

- 位或运算真值表

| \|, or | $0$ | $1$ |
| ------ | --- | --- |
| $0$    | $0$ | $1$ |
| $1$    | $1$ | $1$ |

- 位异或运算真值表

| ^, $\oplus$, xor | $0$ | $1$ |
| ---------------- | --- | --- |
| $0$              | $0$ | $1$ |
| $1$              | $1$ | $0$ |

- 非运算符真值表

| ~, not | $0$ | $1$ |
| ------ | --- | --- |
|        | $1$ | $0$ |

例如 $11 = (1011)_2$ 和 $28 = (11100)_2$ 的按位与、按位或、按位异或分别为 $8 = (01000)_2, 31 = (11111)_2, 23 = (10111)_2$。

非运算需要指定二进制位数。给定 $8$ 位二进制数 $10110110_2$ 做非运算为 $01001001_2$。

### 运算性质

- 交换律：`a & b = b & a`，或、异或同理
- 结合律：`(a & b) & c = a & (b & c)`，或、异或同理
- 与或运算分配律（左右分配律都成立）：`a & (b | c) = (a & b) | (a & c)`，`a | (b & c) = (a | b) & (a | c)`

- 非运算反演律（德摩根律）：`~(a & b) = (~a) | (~b)`，`~(a | b) = (~a) & (~b)`

- 异或性质
  - 单位元 $0$：`a ^ 0 = a`，$0$ 异或任何一个数均不变。
  - $a$ 在异或运算下的逆元为 $a$：`a ^ a = 0`。
    - 前缀运算优化区间查询：加法、乘法、异或。

- 加法与位运算：给定非负整数 $a, b$，`a + b = 2 * (a & b) + (a ^ b)`，`a & b` 考虑的是进位位，`a ^ b` 考虑的是非进位位。

## 原反补码

2147483647 = $0111 \ 1111 \ 1111 \ 1111 \ 1111 \ 1111 \ 1111 \ 1111_2$

对于 $32$ 位数 $x$ 而言，最高位会设立一个符号位，正数符号位为 $0$，负数符号位为 $1$。

原码：$x$ 的二进制表示，最高位为符号位。

反码：正数的反码 = 正数的原码，负数的反码 = 负数的原码除符号位外取反。

补码：正数的补码 = 正数的原码，负数的补码 = 负数的反码 + 1。

| 8位二进制 | 原码      | 反码      | 补码      |
| --------- | --------- | --------- | --------- |
| 12        | 0000 1100 | 0000 1100 | 0000 1100 |
| -12       | 1000 1100 | 1111 0011 | 1111 0100 |

对 C++ 而言，所有整数均是以补码形式存储的。

```cpp
int a = -1;  // 补码为 32 个 1，最高位为符号位
unsigned int b = a; // 补码为 32 个 1，最高位不是符号位
// int: -2^31 ~ 2^31 - 1,  unsigned int: 0 ~ 2^32 - 1
cout << a << ' ' << b;  // -1 4294967295
```

## 移位

### 普通移位（C++ 中的左移右移运算符）

对无符号数而言：

- `a >> x`，将 $a$ 的二进制表示下右移 $x$ 位，高 $x$ 位补 $0$。
- `a << x`，将 $a$ 的二进制表示下左移 $x$ 位，低 $x$ 位补 $0$。

对有符号数而言：

- `a >> x`，将 $a$ 的二进制表示下右移 $x$ 位，高 $x$ 位为符号位，符号位不变。
- `a << x`，将 $a$ 的二进制表示下左移 $x$ 位，低 $x$ 位补 $0$，符号位不变。

```cpp
int a = -1;
cout << (a >> 1) << ' ' << (a << 1);  // -1 -2

// -1 的补码为：1111 ... 1111,32 个 1
// 对有符号数的右移运算，需要把符号位填充到高位, -1 >> 1 = 1111 ... 1111 32 个 1
// 对有符号数进行左移运算，低位补 0：-1 << 1 = 1111 ... 1110，其为 -2 的补码
```

### 循环移位（仅针对无符号数而言）

移除位按顺序补充不足位，$1111 \ 0010$ 循环右移、左移 $1$ 位的结果为 $0111 \ 1001$、$1110 \ 0101$。

在 C++ 中实现对 $32$ 位无符号数 `x` 循环右移 `k` 位：

```cpp
unsigned int x = 11; // 0000 .... 0000 1011
// 11 循环右移三位 0110 ....... 0000 0001
unsigned int y = (x >> 3) | (x << 29);
// x << 29: 0110 0000 ... 0000
// x >> 3: 0000 ... 0000 0001

// 循环右移 k 位 (x >> k) | (x << (32 - k))
// 循环左移 k 位 (x << k) | (x >> (32 - k))
```

## 运算符优先级简表

![](https://bkimg.cdn.bcebos.com/pic/63d9f2d3572c11df57c9a205612762d0f703c2f8?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto)

## 位运算操作

默认 $x$ 为无符号数。 

| 操作                                         | 功能                      | 解释                                                           |
| -------------------------------------------- | ------------------------- | -------------------------------------------------------------- |
| `x & (x - 1)`                                | 将最低位的 $1$ 变 $0$     |                                                                |
| `x                                           | (x - 1)`                  | 将低位的后缀 $0$ 全变 $1$                                      |  |
| `x & (x + 1)`                                | 将低位的后缀 $1$ 全变 $0$ |                                                                |
| `x                                           | (x + 1)`                  | 将最低位的 $0$ 变 $1$                                          |  |
| `x & -x`（对有符号数而言），称为 `lowbit(x)` | 取出最低位的 $1$ 的位权   | `-x` 的补码相当于 `x` 的最低位 1 到第 0 位不变，剩下所有位取反 |
| `x >> i & 1`                                 | 取第 $i$ 位               |                                                                |
| `x                                           | (1 << i)`                 | 将第 $i$ 位置 $1$                                              |  |
| `x & (~(1 << i))`                            | 将第 $i$ 位置 $0$         |                                                                |
| `x ^ (1 << i)`                               | 将第 $i$ 位取反           |                                                                |
| `(a & b) << 1 + (a ^ b)`                     | `a + b`                   |                                                                |
| `~x`                                         | 判断 $x$ 是否为 $-1$      |                                                                |
| `!x`                                         | 判断 $x$ 是否为 $0$       |                                                                |

## *状压枚举

### 压缩表示

例如，有 $5$ 个元素 $a_1 \dots a_5$，我们选择了$a_2, a_3, a_5$。

- 可以用大小为 $5$ 的布尔数组表示每个元素是否选取。
- 可以用二进制 $10110$ 表示每个元素是否选取。
- 大小为 $5$ 的布尔数组概念上等价于 $5$ 位二进制。

状态压缩（压缩表示）：把多个状态合并成一个数值存储表示，简称为状压，通常情况下是一种用二进制来实现枚举的技巧。

在上面例子中，二进制的状态压缩表示 $(10110)_2$ 表示选取了 $a_2, a_3, a_5$ 这三个数字，参见下表。

| 位号     | 4     | 3     | 2     | 1     | 0     |
| -------- | ----- | ----- | ----- | ----- | ----- |
| 代表数字 | $a_5$ | $a_4$ | $a_3$ | $a_2$ | $a_1$ |
| 压缩表示 | 1     | 0     | 1     | 1     | 0     |

### 运算

$n$ 个元素是否选取（$n$ 个元素的子集）可以用 $n$ 位二进制数表示。

有两个 $S_1, S_2$，他们的压缩表示为 $s_1, s_2$。

交集：$S_1 \bigcap S_2$ 等价于 `s1 & s2`

并集：$S_1 \bigcup S_2$ 等价于 `s1 | s2`

差集：$S_1 - S_2$（或 $S_1 \backslash S_2$）等价于 `(s1 | s2) - s2`，`s1 & ~s2`。

属于：$x \in S_1$ 等价于 `(s1 >> x & 1) == 1`。

包含（子集）：$S_2 \subseteq S_1$ 等价于 `(s1 & s2) == s2` 或者 `(s1 | s2) == s1`

### 状压枚举

枚举 $n$ 个元素的所有挑选元素的方案（共 $2^n$ 种）。

```cpp
for (int i = 0; i < (1 << n); i++) {  // n 位二进制，枚举 2^n 种选取方案
  for (int j = 0; j < n; j++) {       // 枚举压缩表示的每一位
  	if (i >> j & 1) {                 // 输出子集
      cout << j << ' ';
    }
  }
  cout << '\n';
}
```

### 例题：coverage

```cpp
#include <iostream>

using namespace std;

const int MAXM = 10;

int n, m, k, ans, s[MAXM];  // s[i] 对应了一个 10 位的二进制数，用来表示 1 ~ 10 每个元素是否选取

int main() {
  cin >> n >> m;
  for (int i = 0; i < m; i++) {
    cin >> k;
    for (int j = 0, x; j < k; j++) {
      cin >> x;              // 第 i 个集合包含数字 x
      s[i] |= 1 << (x - 1);  // 将第 x 位置 1
    }
  }
  for (int i = 0; i < (1 << m); i++) {  // 枚举挑选集合的方案
    int total = 0;
    for (int j = 0; j < m; j++) {  // 确定挑了哪些集合
      if (i >> j & 1) {            // i 对应的挑选集合方案中包含了第 j 个集合
        total |= s[j];             // 当前方案包含了 s[j] 压缩表示下对应的数字
      }
    }
    ans += total == (1 << n) - 1;  // 包含了 1 ~ n 所有数字
  }
  cout << ans;
  return 0;
}
```

总时间 $O(m2^m)$。

# 例题

## 寻找团伙

成功率、每个人所拥有的的能力、可以用 $k$ 位二进制数表示。

给定 $n$ 个人，每个人的能力用 $k$ 位二进制数表示，请你挑选出一些人构成的子集（$21$ 位二进制数），使得这些人的能力的异或和（偶数个能力贡献为 $0$，奇数个能力贡献为 $2^i$）最大。

使用状压枚举，总时间 $O(n2^n)$。

## KOMPIĆI

如果把状态设计为【第 $i$ 个数 $A_i$】，总时间 $O(N^2)$。

实际上只需要看 $A_i, A_j$ 中是否有相同数字。每个 $A_i$ 所包含的数字可以用 $10$ 位二进制数 $x$ 表示。十位二进制数最多为 $1024$ 个状态。

$A_i = 13579$，它对应的二进制 $B_i = 1010101010$。

$A_i, A_j$ 至少有一位相同，等价于 $B_i \ \text{and} \ B_j \ne 0$。重新定义状态为【$cnt_x$ 表示满足 $B_i = x$ 的 $i$ 的数量】。

- 枚举第一个数字对应的二进制 $x$
  - 枚举第二个数字对应的二进制 $y$
    - 如果 `x & y`，计算对答案的贡献。

总时间 $O((2^{10})^2) = O(2^{20})$。

## 吃月饼

### 60 分

暴力枚举 $A \sim B$ 中的每个数字 $x$，维护 $x$ 中 $1$ 的数量的最大值。

### 100 分

令 $ans = (111111\dots)_2$，每个月饼都吃。贪心思路是，每次尽可能去掉重量大的月饼。

从高位到低位枚举月饼重量 $2^i$，每次尽可能去掉重量大的月饼，直到重量符合要求：

- $ans - 2^i \lt A$，必须吃。
- $ans - 2^i \gt B$，必须不吃。

总时间 $O(\log B)$。

## Ternary Decomposition

可以先将 $N$ 转成 $3$ 进制，顺便求出最少 $x$ 个 $3$ 的幂次。

- $x \lt K$，不断将最大的 $1$ 个 $3^i$ 分解为 $3$ 个 $3^{i - 1}$，新增 $2$ 个 $3$ 的幂次，$2$ 为偶数。只用判断 $x, K$ 的奇偶性。
- $X = K$，合法。

- $x \gt K$，非法。

时间复杂度 $O(\log N)$。

## 数列

考虑 $K = 2$，实际上答案就是 $N$。

考虑在 $K$ 进制数下，每一位只能填 $0, 1$，按照二进制方式填 $0, 1$。将 $N$ 做二进制分解为 $2^a + 2^b+ \dots$，然后求 $k^a + k^b + \dots$。

实际上无需做二进制分解，而只用看 $N$ 在二进制表示下第 $i$ 位是否为 $1$。

总时间 $O(\log N)$。

## 倒水

$N$ 的二进制表示中 $1$ 的数量是瓶子的**最多**数量 $cnt$。

- $cnt \gt k$，你至少需要 $2^i$ 个瓶子，其中 $i$ 是 $N$ 的二进制表示中最低位的 $1$。
- 然后让 $N$ 加上 $cnt$。可以发现 $N + cnt$ 的二进制中 $1$ 的个数不会变得更多。
# 差分

## 一维差分

给定长度为 $n$ 的整数序列 $a_1, a_2, \dots, a_n$，它的差分序列定义为相邻两项之差，即 $d_i = a_i - a_{i - 1}$（$1 \le i \le n$），其中 $a_0 = 0$。

例如，当 $a$ 序列为 $[1, 4, 3, 2, 6]$ 时，它的差分序列 $d$ 为 $[1, 3, -1, -1, 4]$。

对于差分序列：$d_1 = a_1, d_2 = a_2 - a_1, d_3 = a_3 - a_2, \dots, d_n = a_n - a_{n - 1}$，我们可以发现：

- $d_1 = a_1$
- $d_1 + d_2 = a_1 + (a_2 - a_1) = a_2$
- $d_1 + d_2 + d_3 = a_1 + (a_2 - a_1) + (a_3 - a_2) = a_3$
- $\dots$

也就是说，对差分序列做前缀和运算，可以还原出原数组 $a$，即 $\sum \limits_{k = 1}^i d_k = a_i$（$1 \le i \le n$）。

换句话说，差分与前缀和是一对逆运算。

## 区间修改

给定长度为 $N$ 的序列 $A_1, A_2, \dots, A_n$。有 $Q$ 次操作，每次操作为对区间 $[l, r]$ 内的所有元素 $a_l, \dots, a_r$ 都增加 $x$。求出操作完毕后的 $A$ 数组。

如果暴力循环修改元素，单次操作的时间复杂度为 $O(N)$，总时间复杂度为 $O(QN)$，太慢了。我们观察在操作前后的原数组 $A$ 和它的差分数组 $D$。

$$
A = [A_1, A_2, \dots, A_{l - 1}, A_l, A_{l + 1}, \dots, A_r, A_{r + 1}, \dots, A_N] \\ 
D = [D_1, D_2, \dots, D_{l - 1}, D_l, D_{l + 1}, \dots, D_r, D_{r + 1}, \dots, D_N]
$$

在操作之后：

$$
A = [A_1, A_2, \dots, A_{l - 1}, A_l + x, A_{l + 1} + x, \dots, A_r + x, A_{r + 1}, \dots, A_N] \\ 
D = [D_1, D_2, \dots, D_{l - 1}, D_l + x, D_{l + 1}, \dots, D_r, D_{r + 1} + x, \dots, D_N]
$$

可以发现，如果对原数组 $A_l, \dots, A_r$ 都增加 $x$，相当于在差分数组进行了两个元素的修改：

- $D_l$ 增加 $x$。
- $D_{r + 1}$ 减少 $x$。
- $l$ 和 $r + 1$ 被称为差分点。

我们可以首先求出原数组 $A$ 的差分数组 $D。然后对于每次区间修改操作，我们可以在差分数组上进行两次修改，在所有操作完之后，对差分数组求前缀和就还原得到了原数组。单次区间修改的时间复杂度为 $O(1)$。总时间复杂度为 $O(N + Q)$。

??? 代码

    ```cpp
    int a[MAXN], d[MAXN];
    int n, q, l, r, x;

    for (int i = 1; i <= n; i++) {
      d[i] = a[i] - a[i - 1];
    }
    for (int i = 1; i <= q; i++) {
      cin >> l >> r >> x;
      d[l] += x, d[r + 1] -= x;
    }
    for (int i = 1; i <= n; i++) {
      a[i] = a[i - 1] + d[i];
    }
    ```

## 矩阵修改

（该知识点较难，选学）

假设我们有一个 $N$ 行 $M$ 列的矩阵，一开始元素均为 $0$。每次操作会对一个子矩阵中的元素整体加 $1$，求出 $Q$ 次操作后的矩阵。

如果暴力修改，时间复杂度显然为 $O(QM)$，太慢了。

借用一维数组上的差分思想，我们可以对待修改子矩阵的每一行进行区间修改，在两个差分点处分别加减 $1$。所有操作执行后，通过每一行的一维前缀和还原原矩阵。

假设 $N = 5, M = 6$，我们对第 $2$ 行到第 $4$ 行、第 $3$ 列到第 $5$ 列进行修改。下图对应了矩阵 $A$ 和每一行都做一次差分后的矩阵 $D_1$。

$$
A = 
\begin{bmatrix}
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 1 & 1 & 0 \\
0 & 0 & 1 & 1 & 1 & 0 \\
0 & 0 & 1 & 1 & 1 & 0 \\
0 & 0 & 0 & 0 & 0 & 0
\end{bmatrix} \xrightleftharpoons[每行做前缀和]{每行做差分}
D_1=
\begin{bmatrix}
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 & -1 \\
0 & 0 & 1 & 0 & 0 & -1 \\
0 & 0 & 1 & 0 & 0 & -1 \\
0 & 0 & 0 & 0 & 0 & 0
\end{bmatrix}
$$

此时我们将子矩阵的修改操作，变成了子矩阵中每行 $2$ 个差分点、一共最多 $2N$ 个差分点的修改操作。修改的总时间复杂度为 $O(QN)$，修改完后，对每一行做前缀和还原原矩阵，时间复杂度为 $O(NM)$，总时间复杂度为 $O(QN + NM)$。

实际上，观察到 $D_1$ 矩阵仍然有一段连续相同的部分，我们再对 $D_1$ 的每一列做差分，得到矩阵 $D_2$。

$$
D_1 = 
\begin{bmatrix}
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 & -1 \\
0 & 0 & 1 & 0 & 0 & -1 \\
0 & 0 & 1 & 0 & 0 & -1 \\
0 & 0 & 0 & 0 & 0 & 0
\end{bmatrix} \xrightleftharpoons[每列做前缀和]{每列做差分}
D_2=
\begin{bmatrix}
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 & -1 \\
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & -1 & 0 & 0 & -1
\end{bmatrix}
$$

相当于，对原矩阵 $A$ 做列维度差分得到 $D_1$，然后对 $D_1$ 做行维度差分得到 $D_2$。

> 注意，每一行做差分，实际是对列这个维度做差分；每一列做差分，实际是对行这个维度做差分。

也就是说，对于一次子矩阵修改操作，我们可以在矩阵 $D_2$ 上做 $4$ 次修改。所有子矩阵修改操作执行完后，对矩阵 $D_2$ 做每一列的前缀和得到 $D_1$，然后对 $D_1$ 做每一行前缀和还原原矩阵 $A$。此时每次子矩阵修改的时间复杂度为 $O(1)$，总时间复杂度为 $O(Q + NM)$。

类似于逐维计算前缀和，我们把这样的差分技巧称为**逐维差分**。

$A, D_1, D_2$ 之间的关系如下：

$$
A \xrightleftharpoons[列维度前缀和]{列维度差分} D_1 \xrightleftharpoons[行维度前缀和]{行维度差分} D_2
$$

实际上，我们也可以对矩阵 $D_2$ 的每行求出前缀和得到 $D_3$，然后对 $D_3$ 的每列求前缀和得到 $A$。

$$
A = 
\begin{bmatrix}
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 1 & 1 & 0 \\
0 & 0 & 1 & 1 & 1 & 0 \\
0 & 0 & 1 & 1 & 1 & 0 \\
0 & 0 & 0 & 0 & 0 & 0
\end{bmatrix} \xrightleftharpoons[每列做前缀和]{每列做差分}
D_3=
\begin{bmatrix}
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 1 & 1 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & -1 & -1 & -1 & 0
\end{bmatrix}
$$

$$
D_3=
\begin{bmatrix}
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 1 & 1 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & -1 & -1 & -1 & 0
\end{bmatrix} \xrightleftharpoons[每行做前缀和]{每行做差分}
D_2=
\begin{bmatrix}
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 & -1 \\
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & -1 & 0 & 0 & -1
\end{bmatrix}
$$

$$
A \xrightleftharpoons[行维度前缀和]{行维度差分} D_3 \xrightleftharpoons[列维度前缀和]{列维度差分} D_2
$$

## 题目

洛谷 P2367 P3397

逐月 P1420 P1421 P1422
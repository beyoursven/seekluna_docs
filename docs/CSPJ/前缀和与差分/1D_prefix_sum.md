# 一前缀和

假设我们有一个从 $1$ 下标开始的长度为 $N$ 的数组 $A$，然后有 $Q$ 次询问，每次询问给出一对满足 $1 \le l \le r \le n$ 的整数 $(l, r)$，请你求出 $A_l + A_{l + 1} + \dots + A_r$ 的和。通俗来说，就是请你求出 $Q$ 次区间和。

从暴力的角度来说，对于每次询问我们可以遍历从 $A_l$ 到 $A_r$ 的元素并求和。由于我们有 $Q$ 次询问，每次询问最坏情况下需要花费 $O(N)$ 的时间计算子段和，因此总时间复杂度为 $O(QN)$。对于这类题目，数据范围限制通常为 $N, Q \le 10^5$，因此暴力做法会超时，通常只能获取部分分。

此时我们可以使用前缀和进行优化。

## 前缀和的定义

定义 $pre_i$（$1 \le i \le N$）表示数组中前 $i$ 个元素之和，即：

$$
pre_i = \sum \limits_{k = 1}^i A_i
$$

## 前缀和的预处理

对于每个 $pre_i$（$1 \le i \le N$），如果我们通过遍历前 $i$ 个元素来求出，时间复杂度高达 $O(N^2)$。可以简单地发现，$pre_i$ 可以通过以下递推式计算得出：

$$
pre_i = pre_{i - 1} + A_i
$$

由于数组是从 $1$ 下标开始的，因此 $pre_{0} = 0$。

举个例子，对于数组 $A = [1, 6, 4, 2, 5, 3]$，前缀和如下表所示：

| 下标 $i$ |  $0$  |  $1$  |  $2$  |  $3$  |  $4$  |  $5$  |  $6$  |
| :------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|  $A_i$   |  $0$  |  $1$  |  $6$  |  $4$  |  $2$  |  $5$  |  $3$  |
| $pre_i$  |  $0$  |  $1$  |  $7$  | $11$  | $13$  | $18$  | $21$  |

??? 代码

    === "代码 1"

        ```cpp
        int a[MAXN], pre[MAXN];
        int n;

        for (int i = 1; i <= n; i++) {
          pre[i] = pre[i - 1] + a[i];
        }
        ```

    === "代码 2"

        ```cpp
        int a[MAXN];
        int n;

        for (int i = 1; i <= n; i++) {
          a[i] += a[i - 1];
        }
        ```

## 使用前缀和优化区间查询

此时，如果我们要求出 $A_l + A_{l + 1} + \dots + A_r$，我们可以通过以下式子计算出：

$$
\begin{align}
A_l + A_{l + 1} + \dots + A_r & = (A_1 + A_2 + \dots + A_r) - (A_1 + A_2 + \dots + A_{l - 1}) \\ 
& = \sum \limits_{i = 1}^r A_i - \sum \limits_{i = 1}^{l - 1} A_i \\
& = pre_r - pre_{l - 1}
\end{align}
$$

??? 代码

    ```cpp
    int query(int l, int r) {
      return pre[r] - pre[l - 1];
    }
    ```

## 总结

我们通过 $O(N)$ 预处理前缀和数组 $pre_i$，可以在每次询问时 $O(1)$ 计算区间和 $pre_r - pre_{l - 1}$，总共有 $Q$ 次询问。

总时间复杂度为 $O(N + Q)$。

## 题目

逐月 P1468 P1469 P1470 P1416